Services overview  |  Android DevelopersAndroid Developers
          Platform
        
          Android Studio
        
          Google Play
        
          Android Jetpack
        
          Docs
        
          News
        
    
    
    
      Documentation
    
    
  
          Overview
        
          Guides
        
          Reference
        
          Samples
        
          Design & Quality
        







          Platform
        



          Android Studio
        



          Google Play
        



          Android Jetpack
        



          Docs
        




          Overview
        



          Guides
        



          Reference
        



          Samples
        



          Design & Quality
        






          News
        












App BasicsIntroductionBuild your first appOverviewCreate an Android projectRun your appBuild a simple user interfaceStart another activityApp fundamentalsApp resourcesOverviewHandle configuration changesLocalizationLocalize your appTest your app with pseudolocalesUnicode and internationalization supportLanguage and locale resolutionComplex XML resourcesResource typesOverviewAnimationColor state listDrawableLayoutMenuStringStyleFontMore typesApp manifest fileOverview<action><activity><activity-alias><application><category><compatible-screens><data><grant-uri-permission><instrumentation><intent-filter><manifest><meta-data><path-permission><permission><permission-group><permission-tree><provider><receiver><service><supports-gl-texture><supports-screens><uses-configuration><uses-feature><uses-library><uses-permission><uses-permission-sdk-23><uses-sdk>App permissionsOverviewRequest app permissionsApp permissions best practicesDefine custom permissionsDevicesDevice compatibilityOverviewScreen compatibility overviewSupport different screen sizesSupport different pixel densitiesSupport display cutoutsDeclare restricted screen supportMultiple APK supportOverviewCreate multiple APKs for different API levelsCreate multiple APKs for different screen sizesCreate multiple APKs for different GL texturesCreate multiple APKs with several dimensionsSupport different languages and culturesSupport different platform versionsFilters on Google PlayWearOverviewAdding wearable features to notificationsOverviewCreating a notificationNotification stylesBridging mode for notificationsMaintaining compatibilityCreating wearable appsOverviewCreating and running a wearable appStandalone appsCreating custom layoutsKeeping your app visibleAuthentication in WearAdding voice capabilitiesPackaging and distributing Wear appsDebugging a Wear appCapturing Wear UI screenshotsCreating Wear apps for ChinaCreating custom UIsOverviewDefining layoutsCreating listsShowing confirmationsExiting full-screen activitiesUsing the Wear UI libraryWear navigation and actionsMulti-function buttonsRotary inputCreating input method editorsUsing wrist gesturesSending and syncing dataOverviewNetwork access and syncingAccessing the wearable data layerSyncing data itemsTransferring assetsSending and receiving messagesHandling data layer eventsMigrating Wear apps to GoogleApiCreating data providersOverviewExpose data to complicationsCreating watch facesOverviewDesigning watch facesBuilding a watch face serviceDrawing watch facesWatch face complicationsExposing data to complicationsAdding complications to a watch faceCreating interactive watch facesProviding configuration activitiesAddressing common issuesOptimizing watch facesDetecting locationRequesting PermissionsUsing the SpeakerAndroid TVOverviewBuilding TV AppsOverviewGetting started with TV appsHandling TV hardwareManaging TV controllersBuilding TV layoutsCreating TV navigationBuilding TV playback appsOverviewCreating a catalog browserProviding a card viewBuilding a details viewUsing Leanback transport controlsDisplaying a now playing cardAdding a guided stepIntroducing first-time users to your appEnabling background playbackHelping users find content on TVOverviewRecommending TV contentOverviewChannels on the home screenVideo program attributesAudio program attributesGame program attributesWatch next attributesPreviewing videosRecommendations in Android N and earlierMaking TV apps searchableSearching within TV AppsBuilding TV gamesBuilding TV channelsOverviewDeveloping a TV input serviceWorking with channel dataManaging user interactionSupporting time-shiftingSupporting content recordingTV Apps checklistAndroid AutoOverviewGetting Started with AutoPlaying Audio for AutoMessaging for AutoTesting for AutoAndroid ThingsOverviewPlatform differencesGoogle servicesSupported hardwareDeveloper kitsGet startedNXP i.MX7DRaspberry Pi 3Advanced setupOverviewManually flash an imageRecover a deviceConnecting to Wi-Fi with adbBuild appsCreate a Things appOverviewCreate a projectConnect the hardwareInteract with peripheralsIntegrate peripheral driversCommunicate with wireless devicesBluetoothLoWPANConfigure devicesSettingsUpdatesInteract with peripheralsOverviewGPIOPWMI2CSPIUARTNative PIOCLI toolIntegrate native codeBuild user-space driversOverviewLocationInputSensorsLoWPANSamplesManage devicesOverviewCreate a productConfigure a productCreate a buildOverviewManage appsPush an updateOverviewAutomatic updatesMonitor analyticsTermsConsole Terms of ServiceSDK License AgreementAndroid Things ConsoleChrome OS devicesOverviewBuilding apps for Chrome OSPreparing your development environmentOptimizing Apps for Chrome OSResolving Issues with Screen SizeApp Manifest Compatibility for ChromebooksLoading Apps on ChromebooksChrome OS Device Support for AppsApp Rendering Differences on ChromebooksWindow managementInput compatibility for ChromebooksAndroid Studio on Chrome OSChrome OS devices on EmulatorTest Cases for Android Apps on Chrome OSCore topicsActivitiesIntroduction to activitiesThe activity lifecycleActivity state changesTest your activitiesTasks and back stackProcesses and app lifecycleParcelables and bundlesFragmentsOverviewCreate a fragmentTest your fragmentsBuild a flexible UICommunicate with other fragmentsInteract with other appsOverviewSending the user to another appGetting a result from an activityAllowing other apps to start your activityHandling app linksOverviewEnabling links to app contentVerify app linksCreate app links for instant appsLoadersRecents screenMulti-window supportApp shortcutsOverviewCreate shortcutsManage shortcutsBest practices for shortcutsApp widgetsOverviewBuild an app widgetBuild an app widget hostArchitecture ComponentsOverviewAdding Components to your ProjectData Binding LibraryOverviewGet startedLayouts and binding expressionsWork with observable data objectsGenerated binding classesBinding adaptersBind layout views to Architecture ComponentsTwo-way data bindingHandling LifecyclesLiveDataNavigationOverviewImplement NavigationUpdate UI components with NavigationUINested graphsPass data between destinationsAdd support for new destinationImplement conditional navigationCreate a deep link for a destinationGlobal actionsMigrate to the Navigation ComponentPaging LibraryOverviewUI Components and ConsiderationsData Components and ConsiderationsRoom Persistence LibraryViewModelWorkManagerOverviewBasicsAdvancedMigrating from Firebase JobDispatcherSaving StatesRelease notesIntents and intent filtersOverviewCommon intentsUser interface & navigationOverviewLayoutsOverviewBuild a responsive UI with ConstraintLayoutCreate a list with RecyclerViewCreate a card-based layoutImplementing adaptive UI flowsImproving layout performanceOverviewOptimizing layout hierarchiesRe-using layouts with <include/>Delayed loading of viewsMaking ListView scrolling smoothLinear layoutAdapter viewRelative layoutCustom view componentsOverviewCreating a custom view classImplementing custom drawingMaking the view interactiveOptimizing the viewLook and feelMaterial designStyles and themesAdaptive iconsAdd a floating action buttonCreate shadows and clip viewsTextAutosizing TextViewsDownloadable fontsFonts in XMLEmoji compatibilityMagnifier widgetSpansButtonsCheckboxesRadio buttonsToggle buttonsSpinnersPickersTooltipsNotificationsOverviewCreate a notificationCreate an expandable notificationStart an activity from a notificationCreate a group of notificationsCreate and manage notification channelsModify a notification BadgeCreate a custom notificationAdd the app barOverviewSet up the app barAdd and handle actionsAdd an up actionUse action views and action providersControl the system UI visibilityOverviewDim the system barsHide the status barHide the navigation barEnable fullscreen modeRespond to UI visibility changesDesigning effective navigationOverviewPlanning screens and their relationshipsPlanning for multiple touchscreen sizesProviding descendant and lateral navigationDesigning back and up navigationPutting it all together: wireframing the example appImplementing effective navigationOverviewCreating swipe views with tabsCreating a navigation drawerProviding up navigationProviding proper back navigationImplementing descendant navigationSlide between fragments using ViewPagerSupporting swipe-to-refreshOverviewAdding swipe-to-refresh to your appResponding to a refresh gestureToasts overviewPop-up messages overviewOverviewBuild and display a pop-up messageAdd an action to a messageDialogsMenusSettingsOverviewOrganize your settingsCustomize your settingsUse saved valuesBuild a hierarchy in codeHandle other form factorsPreference components and attributesSearchOverviewCreating a search interfaceAdding recent query suggestionsAdding custom suggestionsSearchable configurationAdding search functionalityOverviewSetting up the search interfaceStoring and searching for dataRemaining backward compatibleCopy and pasteDrag and dropCreating backward-compatible UIsOverviewAbstracting the new APIsProxying to the new APIsCreating an implementation with older APIsUsing the version-aware componentAnimations & transitionsOverviewAnimations overviewProperty animation overviewAnimate drawable graphicsReveal or hide a view using animationMove a view using animationMove a view using a fling animationEnlarge a view using a zoom animationAnimate movement using spring physicsAuto animate layout updatesAnimate layout changes using a transitionCreate a custom transition animationStart an activity using an animationImages & graphicsOverviewDrawables overviewVector drawables overviewHandling bitmapsSelecting colors with the palette APIReducing image download sizesHardware accelerationOpenGL ESDisplaying graphics with OpenGL ESOverviewBuilding an OpenGL ES environmentDefining shapesDrawing shapesApplying projection and camera viewsAdding motionResponding to touch eventsRenderingOverviewReducing overdrawPerformance and view hierarchiesAnalyzing with profile GPU renderingEnhancing graphics with wide color contentAudio & videoAudio & video overviewSupported media formatsMedia app architectureMedia app architecture overviewUsing a media sessionBuilding an audio appAudio app overviewBuilding a media browser serviceBuilding a media browser clientMedia session callbacksBuilding a video appVideo app overviewBuilding a video player activityMedia session callbacksResponding to media buttonsHandling changes in audio outputManaging audio focusThe Google Assistant and media appsRouting between devicesRouting overviewMediaRouter overviewMediaRouteProvider overviewControl amplitude with VolumeShaperMediaPlayer overviewMediaRecorder overviewExoPlayerBackground tasksOverviewGuide to background processingSending operations to multiple threadsOverviewSpecify the code to run on a threadCreate a manager for multiple threadsRun code on a thread pool threadCommunicate with the UI threadSchedule jobs intelligentlyServicesOverviewCreate a background serviceSend work requests to the background serviceReport work statusBound servicesAIDL overviewBackground optimizationsBroadcasts overviewImplicit Broadcast ExceptionsManage device awake stateOverviewKeep the device awakeSchedule repeating alarmsApp data & filesOverviewStorage overviewSave files on device storageSave key-value dataSave data in a local databaseOverviewDefine data using entitiesCreate views into a databaseAccess data using DAOsMigrate your databaseTest your databaseReference complex dataSharing simple dataOverviewSending simple data to other appsReceiving simple data from other appsAdding an easy share actionSharing filesOverviewSetting up file sharingSharing a fileRequesting a shared fileRetrieving file informationSharing files with NFCOverviewSending files to another deviceReceiving files from another devicePrinting filesOverviewPrinting photosPrinting HTML documentsPrinting custom documentsContent providersOverviewContent provider basicsCreating a content providerOpen files using storage access frameworkCreate a custom document providerApp install locationUser data & identityOverviewAdd sign-in workflowAutofill frameworkOverviewOptimize your app for autofillBuild autofill servicesCalendar provider overviewContacts providerOverviewRetrieving a list of contactsRetrieving details for a contactModifying contacts using intentsDisplaying the quick contact badgeAccount transferData backupOverviewBack up user dataBack up key-value pairsOverviewRegisterTest backup and restoreBest practices for unique identifiersRemember and authenticate usersOverviewRemember your userAuthenticate to OAuth2 servicesCreate a custom account typeUser locationOverviewOptimize location for batteryGet the last known locationChange location settingsReceive location updatesDisplay a location addressCreate and monitor geofencesDetect when users start an activityMigrate to location and context APIsAdd mapsTouch & inputOverviewInput eventsUsing touch gesturesOverviewDetect common gesturesTrack touch and pointer movementsAnimate a scroll gestureHandle multi-touch gesturesDrag and scaleManage touch events in a ViewGroupHandling keyboard inputOverviewSpecifying the input method typeHandling input method visibilitySupporting keyboard navigationHandling keyboard actionsSupporting game controllersOverviewHandling controller actionsSupporting controllers across Android versionsSupporting multiple game controllersInput method editorsCreating an input methodImage keyboardSpelling checkerCameraOverviewTaking photosRecording videosControlling the cameraCamera APISensorsOverviewSensors overviewMotion sensorsPosition sensorsEnvironment sensorsRaw GNSS measurementsConnectivityOverviewPerforming network operationsOverviewConnect to the networkManage network usageOptimize network data usageParse XML dataTransmit network data using VolleyOverviewSend a simple requestSet up RequestQueueMake a standard requestImplement a custom requestPerform network operations using CronetOverviewSend a simple requestCronet request lifecycleReferenceorg.chromium.netOverviewCallbackExceptionCronetEngineOverviewCronetEngine.BuilderOverviewLibraryLoaderCronetExceptionInlineExecutionProhibitedExceptionNetworkExceptionQuicExceptionUploadDataProviderUploadDataProvidersUploadDataSinkUrlRequestOverviewBuilderCallbackStatusStatusListenerUrlResponseInfoOverviewHeaderBlockTransferring data without draining the batteryOverviewOptimize downloads for efficient network accessMinimize the effect of regular updatesAvoid redundant downloadsModify patterns based on the connectivity typeReduce network battery drainOverviewCollecting network traffic dataAnalyzing data trafficOptimizing user-initiated network useOptimizing app-initiated network useOptimizing server-initiated network useOptimizing general network useTransfer data using Sync AdaptersOverviewCreate a Stub AuthenticatorCreate a Stub Content ProviderCreate a Sync AdapterRun a Sync AdapterBluetoothOverviewBluetooth low energy overviewNFCOverviewNFC basicsAdvanced NFCHost-based card emulation overviewTelecomOverviewBuild a calling appWi-FiWi-Fi scanning overviewWi-Fi peer-to-peer overviewWi-Fi aware overviewWi-Fi location with RTTCompanion device pairing overviewUSBOverviewAccessory overviewHost overviewVPNSession initiation protocol overviewDiscover and connectOverviewUse network service discoveryCreate P2P connections with Wi-FiUse Wi-Fi P2P for service discoveryRenderscriptOverviewAdvanced RenderScriptRuntime API referenceOverviewNumerical typesObject typesConversion functionsMathematical constants and functionsVector math functionsMatrix functionsQuaternion functionsAtomic update functionsTime functions and typesAllocation data access functionsObject characteristics functionsKernel invocation functions and typesInput/output functionsDebugging functionsGraphics functions and typesIndexWeb-based contentOverviewBuilding web apps in WebViewManaging WebView objectsMigrating to WebView in Android 4.4Supporting different screens in web appsDebugging web appsBest practices for web appsAndroid App BundlesOverviewDownload modules with the Play Core LibraryGoogle Play InstantOverview of Google Play InstantGet started with instant appsCreate an instant-enabled app bundleUX best practices for appsGet started with instant gamesOverviewUnity pluginTechnical requirements checklist for gamesUX best practices for gamesReduce the size of your instant app or gameAdd ads to your instant app or gameProvide multiple entry pointsIntegrate with FirebaseAdd Google Analytics for Firebase to your instant appUse Firebase Dynamic Links with instant appsGoogle Play Instant policyResourcesReferenceCode samplesSDK release notesSupportFAQsKnown issuesStackOverflowApp ActionsSlicesOverviewGetting StartedSlice templatesBest practicesTestingOverviewFundamentals of testingSet up projectBuilding effective unit testsOverviewBuilding local unit testsBuilding instrumented unit testsAutomating UI testsOverviewTesting UI for a single appTesting UI for multiple appsTesting app component integrationsOverviewTesting your serviceTesting your content providerTesting UI performanceEspressoOverviewSetup instructionsBasicsRecipesMultiprocessAccessibility checkingListsIntentsWebIdling resourceCheat sheetUI AutomatorJUnit4 RulesAndroidJUnitRunnerSamplesRelease notesPerformanceOverviewAndroid VitalsOverviewStuck Partial Wake LocksExcessive WakeupsExcessive Background Wi-Fi ScansExcessive Background Network UsageANRsCrashesSlow RenderingFrozen FramesPermission DenialsApp Startup TimeApp Standby BucketsProcesses and Threads OverviewBetter Performance through ThreadingOptimizing for Battery LifeOverviewOptimizing for Doze and App StandbyMonitoring the Battery Level and Charging StateDetermining and Monitoring the Docking State and TypeDetermining and Monitoring the Connectivity StatusPower Management RestrictionsAnalyzing Power Use with Battery HistorianTesting power-related issuesReducing APK SizeManage Your App's MemoryOverview of Memory ManagemementDesigning for SeamlessnessKeeping Your App ResponsivePerformance TipsSMP Primer for AndroidVerifying App Behavior on the Android Runtime (ART)AccessibilityOverviewMaking apps more accessibleUsing node tree debuggingBuilding accessibility servicesBuild accessible custom viewsBuild accessibility serviceTest your app's accessibilitySecurityApp security best practicesSecurity tipsSecurity with HTTPS and SSLNetwork security configurationUpdating your security provider to protect against SSL exploitsProtecting against security threats with SafetyNetOverviewSafetyNet Attestation APISafetyNet Safe Browsing APISafetyNet reCAPTCHA APISafetyNet Verify Apps APICryptographyAndroid Keystore SystemVerifying hardware-backed key pairs with key attestationAndroid Protected ConfirmationSupporting Direct BootUsing scoped directory accessApp security improvement programBuild for BillionsOverviewConnectivityDevice capabilityData costBattery consumptionUI and contentBuild for EnterpriseOverviewDeveloper guideWork profilesSet up managed configurationsWork contactsDevice management policiesDevice managementOverviewBuild a device policy controllerWork profiles on fully managed devicesDedicated devicesOverviewLock task modeMultiple usersCookbookDevice controlNetworking and telephonySecuritySystem updatesNetwork activity loggingAndroid versionsOverviewAndroid 9Android 8.0Android 7.0Device administrationGoogle PlayGoogle Play BillingOverviewUse the Google Play Billing LibraryOverviewAdd one-time product-specific featuresAdd subscription-specific featuresPlay Billing Library referencePlay Billing Library release notesUse In-app Billing with AIDLOverviewIn-app Billing ReferenceAdd Real-time Developer NotificationsBest PracticesTest Google Play BillingMaking Your App Content Searchable by GoogleOptimizing Contextual Content for the AssistantGoogle Play Developer APIAPK Expansion FilesApplication LicensingOverviewLicensing OverviewSetting Up for LicensingAdding Licensing to Your AppLicensing ReferenceGoogle Play Install ReferrerOverviewPlay Install Referrer LibraryOverviewReferenceReleases NotesPlay Install Referrer API









    
    
      Android Developers
    
    
    




    
    
      Docs
    
    
    




    
    
      Guides
    
    
    




    Services overview
  


A Service is an application component that can perform
long-running operations in the background, and it doesn't provide a user interface. Another
application component can start a service, and it continues to run in the background even if the
user switches to another application. Additionally, a component can bind to a service to
interact with it and even perform interprocess communication (IPC). For example, a service can
handle network transactions, play music, perform file I/O, or interact with a content provider, all
from the background.
These are the three different types of services:

Foreground

    A foreground service performs some operation that is noticeable to the
    user. For example, an audio app would use a foreground service to play an
    audio track. Foreground services must display a Notification.
    Foreground services continue running even when the user isn't interacting
    with the app.
  
Background
A background service performs an operation that isn't directly noticed by
    the user. For example, if an app used a service to compact its storage,
    that would usually be a background service.

  
    Note: If your app targets API level 26 or higher, the system imposes restrictions on running background
    services when the app itself isn't in the foreground. In most cases like
    this, your app should use a
    scheduled job instead.
  

Bound
A service is bound when an application component binds to it by calling bindService(). A bound service offers a client-server
  interface that allows components to interact with the service, send requests, receive results,
  and even do so across processes with interprocess communication (IPC). A bound service runs only
  as long as another application component is bound to it. Multiple components can bind to the
  service at once, but when all of them unbind, the service is destroyed.

Although this documentation generally discusses started and bound services separately,
your service can work both ways—it can be started (to run indefinitely) and also allow
binding. It's simply a matter of whether you implement a couple of callback methods: onStartCommand() to allow components to start it and onBind() to allow binding.
Regardless of whether your service is started, bound, or both, any application component
can use the service (even from a separate application) in the same way that any component can use
an activity—by starting it with an Intent. However, you can declare
the service as private in the manifest file and block access from other applications.
This is discussed more in the section about Declaring the service in the
manifest.
Caution: A service runs in the
main thread of its hosting process; the service does not create its own
thread and does not run in a separate process unless you specify otherwise. If
your service is going to perform any CPU-intensive work or blocking operations, such as MP3
playback or networking, you should create a new thread within the service to complete that work.
By using a separate thread, you can reduce the risk of Application Not Responding (ANR) errors,
and the application's main thread can remain dedicated to user interaction with your
activities.
Choosing between a service and a thread
A service is simply a component that can run in the background, even when the user is not
interacting with your application, so you should create a service only if that is what you
need.
If you must perform work outside of your main thread, but only while the user is interacting
with your application, you should instead create a new thread. For example, if you want to
play some music, but only while your activity is running, you might create
a thread in onCreate(), start running it in onStart(), and stop it in onStop(). Also consider using AsyncTask or HandlerThread
instead of the traditional Thread class. See the Processes and
Threading document for more information about threads.
Remember that if you do use a service, it still runs in your application's main thread by
default, so you should still create a new thread within the service if it performs intensive or
blocking operations.
The basics
To create a service, you must create a subclass of Service or use one
of its existing subclasses. In your implementation, you must override some callback methods that
handle key aspects of the service lifecycle and provide a mechanism that allows the components to
bind to the service, if appropriate. These are the most important callback methods that you should
override:

onStartCommand()
The system invokes this method by calling startService() when another component (such as an activity) requests that the service be started.
When this method executes, the service is started and can run in the
background indefinitely. If you implement this, it is your responsibility to stop the service when
its work is complete by calling stopSelf() or stopService(). If you only want to provide binding, you don't
need to implement this method.
onBind()
The system invokes this method by calling bindService() when another component wants to bind with the service (such as to perform RPC).
In your implementation of this method, you must provide an interface that clients
use to communicate with the service by returning an IBinder. You must always
implement this method; however, if you don't want to allow binding, you should return
null.
onCreate()
The system invokes this method to perform one-time setup procedures when the service is
initially created (before it calls either
onStartCommand() or
onBind()). If the service is already running, this method is not
called.
onDestroy()
The system invokes this method when the service is no longer used and is being destroyed.
Your service should implement this to clean up any resources such as threads, registered
listeners, or receivers. This is the last call that the service receives.

If a component starts the service by calling startService() (which results in a call to onStartCommand()), the service
continues to run until it stops itself with stopSelf() or another
component stops it by calling stopService().
If a component calls
bindService() to create the service and onStartCommand() is not called, the service runs
only as long as the component is bound to it. After the service is unbound from all of its clients,
the system destroys it.
The Android system force-stops a service only when memory is low and it must recover system
resources for the activity that has user focus. If the service is bound to an activity that has user
focus, it's less likely to be killed; if the service is declared to run in the foreground, it's rarely killed.
If the service is started and is long-running, the system lowers its position
in the list of background tasks over time, and the service becomes highly susceptible to
killing—if your service is started, you must design it to gracefully handle restarts
by the system. If the system kills your service, it restarts it as soon as resources become
available, but this also depends on the value that you return from onStartCommand(). For more information
about when the system might destroy a service, see the Processes and Threading
document.
In the following sections, you'll see how you can create the
startService() and
bindService() service methods, as well as how to use
them from other application components.
Declaring a service in the manifest
You must declare all services in your application's
manifest file, just as you do for activities and other components.
To declare your service, add a <service> element
as a child of the <application>
element. Here is an example:

<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>

See the <service> element
reference for more information about declaring your service in the manifest.
There are other attributes that you can include in the <service> element to
define properties such as the permissions that are required to start the service and the process in
which the service should run. The android:name
attribute is the only required attribute—it specifies the class name of the service. After
you publish your application, leave this name unchanged to avoid the risk of breaking
code due to dependence on explicit intents to start or bind the service (read the blog post, Things
That Cannot Change).

Caution: To ensure that your app is secure, always use an
explicit intent when starting a Service and don't declare intent filters for
your services. Using an implicit intent to start a service is a security hazard because you cannot
be certain of the service that responds to the intent, and the user cannot see which service
starts. Beginning with Android 5.0 (API level 21), the system throws an exception if you call
bindService() with an implicit intent.
You can ensure that your service is available to only your app by
including the android:exported
attribute and setting it to false. This effectively stops other apps from starting your
service, even when using an explicit intent.
Note:
  Users can see what services are running on their device. If they see
  a service that they don't recognize or trust, they can stop the service. In
  order to avoid having your service stopped accidentally by users, you need
  to add the
  android:description
  attribute to the
  <service>
  element in your app manifest. In the description,
  provide a short sentence explaining what the service does and what benefits
  it provides.

Creating a started service
A started service is one that another component starts by calling startService(), which results in a call to the service's
onStartCommand() method.
When a service is started, it has a lifecycle that's independent of the
component that started it. The service can run in the background indefinitely, even if
the component that started it is destroyed. As such, the service should stop itself when its job
is complete by calling stopSelf(), or another component can
stop it by calling stopService().
An application component such as an activity can start the service by calling startService() and passing an Intent
that specifies the service and includes any data for the service to use. The service receives
this Intent in the onStartCommand() method.
For instance, suppose an activity needs to save some data to an online database. The activity
can start a companion service and deliver it the data to save by passing an intent to startService(). The service receives the intent in onStartCommand(), connects to the Internet, and performs the
database transaction. When the transaction is complete, the service stops itself and is
destroyed.
Caution: A service runs in the same process as the application
in which it is declared and in the main thread of that application by default. If your service
performs intensive or blocking operations while the user interacts with an activity from the same
application, the service slows down activity performance. To avoid impacting application
performance, start a new thread inside the service.
Traditionally, there are two classes you can extend to create a started service:

Service
This is the base class for all services. When you extend this class, it's important to
create a new thread in which the service can complete all of its work; the service uses your
application's main thread by default, which can slow the performance of any activity that your
application is running.
IntentService
This is a subclass of Service that uses a worker thread to handle all of
the start requests, one at a time. This is the best option if you don't require that your service
handle multiple requests simultaneously. Implement onHandleIntent(), which receives the intent for each
start request so that you can complete the background work.

The following sections describe how you can implement your service using either one for these
classes.
Extending the IntentService class
Because most of the started services don't need to handle multiple requests simultaneously
(which can actually be a dangerous multi-threading scenario), it's best that you
implement your service using the IntentService class.
The IntentService class does the following:

It creates a default worker thread that executes all of the intents that are delivered to
onStartCommand(), separate from your application's main
thread.
Creates a work queue that passes one intent at a time to your onHandleIntent() implementation, so you never have to
worry about multi-threading.
Stops the service after all of the start requests are handled, so you never have to call
stopSelf().
Provides a default implementation of onBind()
  that returns null.
Provides a default implementation of onStartCommand() that sends the intent to the work queue and then to your onHandleIntent() implementation.

To complete the work that is provided by the client, implement onHandleIntent().
However, you also need to provide a small constructor for the service.
Here's an example implementation of IntentService:

Kotlin

/**
 * A constructor is required, and must call the super [android.app.IntentService.IntentService]
 * constructor with a name for the worker thread.
 */
class HelloIntentService : IntentService("HelloIntentService") {

    /**
     * The IntentService calls this method from the default worker thread with
     * the intent that started the service. When this method returns, IntentService
     * stops the service, as appropriate.
     */
    override fun onHandleIntent(intent: Intent?) {
        // Normally we would do some work here, like download a file.
        // For our sample, we just sleep for 5 seconds.
        try {
            Thread.sleep(5000)
        } catch (e: InterruptedException) {
            // Restore interrupt status.
            Thread.currentThread().interrupt()
        }

    }
}

Java

public class HelloIntentService extends IntentService {

  /**
   * A constructor is required, and must call the super <code><a href="/reference/android/app/IntentService.html#IntentService(java.lang.String)">IntentService(String)</a></code>
   * constructor with a name for the worker thread.
   */
  public HelloIntentService() {
      super("HelloIntentService");
  }

  /**
   * The IntentService calls this method from the default worker thread with
   * the intent that started the service. When this method returns, IntentService
   * stops the service, as appropriate.
   */
  @Override
  protected void onHandleIntent(Intent intent) {
      // Normally we would do some work here, like download a file.
      // For our sample, we just sleep for 5 seconds.
      try {
          Thread.sleep(5000);
      } catch (InterruptedException e) {
          // Restore interrupt status.
          Thread.currentThread().interrupt();
      }
  }
}



That's all you need: a constructor and an implementation of onHandleIntent().
If you decide to also override other callback methods, such as onCreate(), onStartCommand(), or onDestroy(), be sure to call the super implementation so
that the IntentService can properly handle the life of the worker thread.
For example, onStartCommand() must return
the default implementation, which is how the intent is delivered to onHandleIntent():

Kotlin

override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    Toast.makeText(this, "service starting", Toast.LENGTH_SHORT).show()
    return super.onStartCommand(intent, flags, startId)
}

Java

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    Toast.makeText(this, "service starting", Toast.LENGTH_SHORT).show();
    return super.onStartCommand(intent,flags,startId);
}



Besides onHandleIntent(), the only method
from which you don't need to call the super class is onBind(). You need to implement this only if your service allows binding.
In the next section, you'll see how the same kind of service is implemented when extending
the base Service class, which uses more code, but might be
appropriate if you need to handle simultaneous start requests.
Extending the Service class
Using IntentService makes your
implementation of a started service very simple. If, however, you require your service to
perform multi-threading (instead of processing start requests through a work queue), you
can extend the Service class to handle each intent.
For comparison, the following example code shows an implementation of the Service class that performs the same work as the previous example using IntentService. That is, for each start request, it uses a worker thread to perform the
job and processes only one request at a time.

Kotlin

class HelloService : Service() {

    private var serviceLooper: Looper? = null
    private var serviceHandler: ServiceHandler? = null

    // Handler that receives messages from the thread
    private inner class ServiceHandler(looper: Looper) : Handler(looper) {

        override fun handleMessage(msg: Message) {
            // Normally we would do some work here, like download a file.
            // For our sample, we just sleep for 5 seconds.
            try {
                Thread.sleep(5000)
            } catch (e: InterruptedException) {
                // Restore interrupt status.
                Thread.currentThread().interrupt()
            }

            // Stop the service using the startId, so that we don't stop
            // the service in the middle of handling another job
            stopSelf(msg.arg1)
        }
    }

    override fun onCreate() {
        // Start up the thread running the service.  Note that we create a
        // separate thread because the service normally runs in the process's
        // main thread, which we don't want to block.  We also make it
        // background priority so CPU-intensive work will not disrupt our UI.
        HandlerThread("ServiceStartArguments", Process.THREAD_PRIORITY_BACKGROUND).apply {
            start()

            // Get the HandlerThread's Looper and use it for our Handler
            serviceLooper = looper
            serviceHandler = ServiceHandler(looper)
        }
    }

    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
        Toast.makeText(this, "service starting", Toast.LENGTH_SHORT).show()

        // For each start request, send a message to start a job and deliver the
        // start ID so we know which request we're stopping when we finish the job
        serviceHandler?.obtainMessage()?.also { msg ->
            msg.arg1 = startId
            serviceHandler?.sendMessage(msg)
        }

        // If we get killed, after returning from here, restart
        return START_STICKY
    }

    override fun onBind(intent: Intent): IBinder? {
        // We don't provide binding, so return null
        return null
    }

    override fun onDestroy() {
        Toast.makeText(this, "service done", Toast.LENGTH_SHORT).show()
    }
}

Java

public class HelloService extends Service {
  private Looper serviceLooper;
  private ServiceHandler serviceHandler;

  // Handler that receives messages from the thread
  private final class ServiceHandler extends Handler {
      public ServiceHandler(Looper looper) {
          super(looper);
      }
      @Override
      public void handleMessage(Message msg) {
          // Normally we would do some work here, like download a file.
          // For our sample, we just sleep for 5 seconds.
          try {
              Thread.sleep(5000);
          } catch (InterruptedException e) {
              // Restore interrupt status.
              Thread.currentThread().interrupt();
          }
          // Stop the service using the startId, so that we don't stop
          // the service in the middle of handling another job
          stopSelf(msg.arg1);
      }
  }

  @Override
  public void onCreate() {
    // Start up the thread running the service. Note that we create a
    // separate thread because the service normally runs in the process's
    // main thread, which we don't want to block. We also make it
    // background priority so CPU-intensive work doesn't disrupt our UI.
    HandlerThread thread = new HandlerThread("ServiceStartArguments",
            Process.THREAD_PRIORITY_BACKGROUND);
    thread.start();

    // Get the HandlerThread's Looper and use it for our Handler
    serviceLooper = thread.getLooper();
    serviceHandler = new ServiceHandler(serviceLooper);
  }

  @Override
  public int onStartCommand(Intent intent, int flags, int startId) {
      Toast.makeText(this, "service starting", Toast.LENGTH_SHORT).show();

      // For each start request, send a message to start a job and deliver the
      // start ID so we know which request we're stopping when we finish the job
      Message msg = serviceHandler.obtainMessage();
      msg.arg1 = startId;
      serviceHandler.sendMessage(msg);

      // If we get killed, after returning from here, restart
      return START_STICKY;
  }

  @Override
  public IBinder onBind(Intent intent) {
      // We don't provide binding, so return null
      return null;
  }

  @Override
  public void onDestroy() {
    Toast.makeText(this, "service done", Toast.LENGTH_SHORT).show();
  }
}



As you can see, it's a lot more work than using IntentService.
However, because you handle each call to onStartCommand() yourself, you can perform multiple requests simultaneously. That's not what
this example does, but if that's what you want, you can create a new thread for each
request and run them right away instead of waiting for the previous request to finish.
Notice that the onStartCommand() method must return an
integer. The integer is a value that describes how the system should continue the service in the
event that the system kills it. The default implementation for IntentService handles this for you, but you are able to modify it. The return value
from onStartCommand() must be one of the following
constants:

START_NOT_STICKY
If the system kills the service after onStartCommand() returns, do not recreate the service unless there are pending
intents to deliver. This is the safest option to avoid running your service when not necessary
and when your application can simply restart any unfinished jobs.
START_STICKY
If the system kills the service after onStartCommand() returns, recreate the service and call onStartCommand(), but do not redeliver the last intent.
Instead, the system calls onStartCommand() with a
null intent unless there are pending intents to start the service. In that case,
those intents are delivered. This is suitable for media players (or similar services) that are not
executing commands but are running indefinitely and waiting for a job.
START_REDELIVER_INTENT
If the system kills the service after onStartCommand() returns, recreate the service and call onStartCommand() with the last intent that was delivered to the
service. Any pending intents are delivered in turn. This is suitable for services that are
actively performing a job that should be immediately resumed, such as downloading a file.

For more details about these return values, see the linked reference
documentation for each constant. For an extended example of this type of service
implementation, see the MessagingService class in the
MessagingService
sample on GitHub.
Starting a service

  You can start a service from an activity or other application component by
  passing an Intent
  to startService() or startForegroundService(). The
  Android system calls the service's onStartCommand() method and passes it the Intent,
  which specifies which service to start.


Note: If your app targets API level 26 or higher, the system
  imposes restrictions on using or creating background services unless the app
  itself is in the foreground. If an app needs to create a foreground service,
  the app should call startForegroundService(). That method creates a background service, but the
  method signals to the system that the service will promote itself to the
  foreground. Once the service has been created, the service must call its
  startForeground() method within
  five seconds.

For example, an activity can start the example service in the previous section (HelloService) using an explicit intent with startService(), as shown here:

Kotlin

Intent(this, HelloService::class.java).also { intent ->
    startService(intent)
}

Java

Intent intent = new Intent(this, HelloService.class);
startService(intent);



The startService() method returns immediately, and
the Android system calls the service's onStartCommand() method. If the service isn't already running, the system first calls onCreate(), and then it calls
onStartCommand().
If the service doesn't also provide binding, the intent that is delivered with startService() is the only mode of communication between the
application component and the service. However, if you want the service to send a result back,
the client that starts the service can create a PendingIntent for a broadcast
(with getBroadcast()) and deliver it to the service
in the Intent that starts the service. The service can then use the
broadcast to deliver a result.
Multiple requests to start the service result in multiple corresponding calls to the service's
onStartCommand(). However, only one request to stop
the service (with stopSelf() or stopService()) is required to stop it.
Stopping a service
A started service must manage its own lifecycle. That is, the system doesn't stop or
destroy the service unless it must recover system memory and the service
continues to run after onStartCommand() returns. The
service must stop itself by calling stopSelf(), or another
component can stop it by calling stopService().
Once requested to stop with stopSelf() or stopService(), the system destroys the service as soon as
possible.
If your service handles multiple requests to onStartCommand() concurrently, you shouldn't stop the
service when you're done processing a start request, as you might have received a new
start request (stopping at the end of the first request would terminate the second one). To avoid
this problem, you can use stopSelf(int) to ensure that your request to
stop the service is always based on the most recent start request. That is, when you call stopSelf(int), you pass the ID of the start request (the startId
delivered to onStartCommand()) to which your stop request
corresponds. Then, if the service receives a new start request before you are able to call stopSelf(int), the ID doesn't match and the service doesn't stop.
Caution: To avoid wasting system resources and consuming
battery power, ensure that your application stops its services when it's done working.
If necessary, other components can stop the service by calling stopService(). Even if you enable binding for the service,
you must always stop the service yourself if it ever receives a call to onStartCommand().
For more information about the lifecycle of a service, see the section below about Managing the Lifecycle of a Service.
Creating a bound service
A bound service is one that allows application components to bind to it by calling bindService() to create a long-standing connection.
It generally doesn't allow components to start it by calling startService().
Create a bound service when you want to interact with the service from activities
and other components in your application or to expose some of your application's functionality to
other applications through interprocess communication (IPC).
To create a bound service, implement the onBind() callback method to return an IBinder that
defines the interface for communication with the service. Other application components can then call
bindService() to retrieve the interface and
begin calling methods on the service. The service lives only to serve the application component that
is bound to it, so when there are no components bound to the service, the system destroys it.
You do not need to stop a bound service in the same way that you must when the service is
started through onStartCommand().
To create a bound service, you must define the interface that specifies how a client can
communicate with the service. This interface between the service
and a client must be an implementation of IBinder and is what your service must
return from the onBind() callback method. After the client receives the IBinder, it can begin
interacting with the service through that interface.
Multiple clients can bind to the service simultaneously. When a client is done interacting with
the service, it calls unbindService() to unbind.
When there are no clients bound to the service, the system destroys the service.
There are multiple ways to implement a bound service, and the implementation is more
complicated than a started service. For these reasons, the bound service discussion appears in a
separate document about Bound Services.
Sending notifications to the user
When a service is running, it can notify the user of events using Toast Notifications or Status Bar Notifications.
A toast notification is a message that appears on the surface of the current window for only a
moment before disappearing. A status bar notification provides an icon in the status bar with a
message, which the user can select in order to take an action (such as start an activity).
Usually, a status bar notification is the best technique to use when background work such as
a file download has completed, and the user can now act on it. When the user
selects the notification from the expanded view, the notification can start an activity
(such as to display the downloaded file).
See the Toast Notifications or Status Bar Notifications
developer guides for more information.
Running a service in the foreground
A foreground service is a service that the
user is actively aware of and isn't a candidate for the system to kill when low on memory. A
foreground service must provide a notification for the status bar, which is placed under the
Ongoing heading. This means that the notification cannot be dismissed unless the service
is either stopped or removed from the foreground.

Caution: Limit your app's use of foreground services.

  You should only use a foreground service when your app needs to perform a
  task that is noticeable by the user even when they're not directly
  interacting with the app. For this reason, foreground services must show a
  status bar
  notification with a priority of PRIORITY_LOW or higher, which
  helps ensure that the user is aware of what your app is doing. If the action
  is of low enough importance that you want to use a minimum-priority
  notification, you probably shouldn't be using a service; instead, consider
  using a scheduled job.
  

  Every app that runs a service places an additional load on the system,
  consuming system resources. If an app tries to hide its services by using a
  low-priority notification, this can impair the performance of the app the
  user is actively interacting with. For this reason, if an app tries to run a
  service with a minimum-priority notification, the system calls out the app's
  behavior in the notification drawer's bottom section.
  

For example, a music player that plays music from a service should be set to
run in the foreground, because the user is explicitly aware of its operation.
The notification in the status bar might indicate the current song and allow
the user to launch an activity to interact with the music player. Similarly,
an app to let users track their runs would need a foreground service to track
the user's location.

Note: Apps that target Android 9 (API level 28) or higher and use
foreground services must request the
FOREGROUND_SERVICE
permission. This is a
normal
permission, so the system automatically grants it to the requesting app.
If an app that targets API level 28 or higher attempts to create a foreground
service without requesting FOREGROUND_SERVICE,
the system throws a
SecurityException.


To request that your service run in the foreground, call startForeground(). This method takes two
parameters: an integer that uniquely identifies the notification and the
Notification for the status bar. The notification must
have a priority of PRIORITY_LOW or higher. Here is an
example:

Kotlin

val pendingIntent: PendingIntent =
        Intent(this, ExampleActivity::class.java).let { notificationIntent ->
            PendingIntent.getActivity(this, 0, notificationIntent, 0)
        }

val notification: Notification = Notification.Builder(this, CHANNEL_DEFAULT_IMPORTANCE)
        .setContentTitle(getText(R.string.notification_title))
        .setContentText(getText(R.string.notification_message))
        .setSmallIcon(R.drawable.icon)
        .setContentIntent(pendingIntent)
        .setTicker(getText(R.string.ticker_text))
        .build()

startForeground(ONGOING_NOTIFICATION_ID, notification)

Java

Intent notificationIntent = new Intent(this, ExampleActivity.class);
PendingIntent pendingIntent =
        PendingIntent.getActivity(this, 0, notificationIntent, 0);

Notification notification =
          new Notification.Builder(this, CHANNEL_DEFAULT_IMPORTANCE)
    .setContentTitle(getText(R.string.notification_title))
    .setContentText(getText(R.string.notification_message))
    .setSmallIcon(R.drawable.icon)
    .setContentIntent(pendingIntent)
    .setTicker(getText(R.string.ticker_text))
    .build();

startForeground(ONGOING_NOTIFICATION_ID, notification);



Caution: The integer ID that you give to startForeground() must not be 0.
To remove the service from the foreground, call stopForeground(). This method takes a boolean, which indicates
whether to remove the status bar notification as well. This method does not stop the
service. However, if you stop the service while it's still running in the foreground, the
notification is also removed.
For more information about notifications, see Creating Status Bar
Notifications.
Managing the lifecycle of a service
The lifecycle of a service is much simpler than that of an activity. However, it's even more
important that you pay close attention to how your service is created and destroyed because a
service can run in the background without the user being aware.
The service lifecycle—from when it's created to when it's destroyed—can follow
either of these two paths:

A started service
  The service is created when another component calls startService(). The service then runs indefinitely and must
stop itself by calling stopSelf(). Another component can also stop the
service by calling stopService(). When the service is stopped, the system destroys it.
A bound service
  The service is created when another component (a client) calls bindService(). The client then communicates with the service
through an IBinder interface. The client can close the connection by calling
unbindService(). Multiple clients can bind to
the same service and when all of them unbind, the system destroys the service. The service
does not need to stop itself.

These two paths aren't entirely separate. You can bind to a service that is already
started with startService(). For example, you can
start a background music service by calling startService() with an Intent that identifies the music to play. Later,
possibly when the user wants to exercise some control over the player or get information about the
current song, an activity can bind to the service by calling bindService(). In cases such as this, stopService() or stopSelf() doesn't actually stop the service until all of the clients unbind.
Implementing the lifecycle callbacks
Like an activity, a service has lifecycle callback methods that you can implement to monitor
changes in the service's state and perform work at the appropriate times. The following skeleton
service demonstrates each of the lifecycle methods:

Kotlin

class ExampleService : Service() {
    private var startMode: Int = 0             // indicates how to behave if the service is killed
    private var binder: IBinder? = null        // interface for clients that bind
    private var allowRebind: Boolean = false   // indicates whether onRebind should be used

    override fun onCreate() {
        // The service is being created
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // The service is starting, due to a call to startService()
        return mStartMode
    }

    override fun onBind(intent: Intent): IBinder? {
        // A client is binding to the service with bindService()
        return mBinder
    }

    override fun onUnbind(intent: Intent): Boolean {
        // All clients have unbound with unbindService()
        return mAllowRebind
    }

    override fun onRebind(intent: Intent) {
        // A client is binding to the service with bindService(),
        // after onUnbind() has already been called
    }

    override fun onDestroy() {
        // The service is no longer used and is being destroyed
    }
}

Java

public class ExampleService extends Service {
    int startMode;       // indicates how to behave if the service is killed
    IBinder binder;      // interface for clients that bind
    boolean allowRebind; // indicates whether onRebind should be used

    @Override
    public void onCreate() {
        // The service is being created
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        // The service is starting, due to a call to startService()
        return mStartMode;
    }
    @Override
    public IBinder onBind(Intent intent) {
        // A client is binding to the service with bindService()
        return mBinder;
    }
    @Override
    public boolean onUnbind(Intent intent) {
        // All clients have unbound with unbindService()
        return mAllowRebind;
    }
    @Override
    public void onRebind(Intent intent) {
        // A client is binding to the service with bindService(),
        // after onUnbind() has already been called
    }
    @Override
    public void onDestroy() {
        // The service is no longer used and is being destroyed
    }
}



Note: Unlike the activity lifecycle callback methods, you are
not required to call the superclass implementation of these callback methods.

Figure 2. The service lifecycle. The diagram on the left
shows the lifecycle when the service is created with startService() and the diagram on the right shows the lifecycle when the service is created
with bindService().
Figure 2 illustrates the typical callback methods for a service. Although the figure separates
services that are created by startService() from those
created by bindService(), keep
in mind that any service, no matter how it's started, can potentially allow clients to bind to it.
A service that was initially started with onStartCommand() (by a client calling startService())
can still receive a call to onBind() (when a client calls
bindService()).
By implementing these methods, you can monitor these two nested loops of the service's
lifecycle:

The entire lifetime of a service occurs between the time that onCreate() is called and the time that onDestroy() returns. Like an activity, a service does its initial setup in
onCreate() and releases all remaining resources in onDestroy(). For example, a
music playback service can create the thread where the music is played in onCreate(), and then it can stop the thread in onDestroy().

Note: The onCreate()
and onDestroy() methods are called for all services, whether
they're created by startService() or bindService().
The active lifetime of a service begins with a call to either onStartCommand() or onBind().
Each method is handed the Intent that was passed to either startService() or bindService().
If the service is started, the active lifetime ends at the same time that the entire lifetime
ends (the service is still active even after onStartCommand() returns). If the service is bound, the active lifetime ends when onUnbind() returns.


Note: Although a started service is stopped by a call to
either stopSelf() or stopService(), there isn't a respective callback for the
service (there's no onStop() callback). Unless the service is bound to a client,
the system destroys it when the service is stopped—onDestroy() is the only callback received.
For more information about creating a service that provides binding, see the Bound Services document,
which includes more information about the onRebind()
callback method in the section about Managing the lifecycle of
a bound service.



Content and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates.

      
      Last updated February 13, 2019.
    





          
          
            Twitter
          
        Follow @AndroidDev on Twitter
          
          
            YouTube
          
        Check out Android Developers on YouTubeMore Android
                Android
            
                Enterprise
            
                Security
            
                Source
            Support
                Report platform bug
            
                Report documentation bug
            
                Google Play support
            
                Join user studies
            Documentation
                Developer guides
            
                Design guides
            
                API reference
            
                Samples
            
                Android Studio
            
                Android
            
                Chrome
            
                Firebase
            
                Google Cloud Platform
            
                All Products
            
            Bahasa Indonesia
          
            Deutsch
          
            English
          
            español
          
            Español (América Latina)
          
            français
          
            Português Brasileiro
          
            Tiếng Việt
          
            Türkçe
          
            Русский
          
            ภาษาไทย
          
            日本語
          
            简体中文
          
            繁體中文
          
            한국어
          Privacy
         License
         Brand Guidelines
         
        Get Android and Google Play news by email
      
        
        Subscribe
      
