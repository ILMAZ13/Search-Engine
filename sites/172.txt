Optimize location for battery  |  Android DevelopersAndroid Developers
          Platform
        
          Android Studio
        
          Google Play
        
          Android Jetpack
        
          Docs
        
          News
        
    
    
    
      Documentation
    
    
  
          Overview
        
          Guides
        
          Reference
        
          Samples
        
          Design & Quality
        







          Platform
        



          Android Studio
        



          Google Play
        



          Android Jetpack
        



          Docs
        




          Overview
        



          Guides
        



          Reference
        



          Samples
        



          Design & Quality
        






          News
        












App BasicsIntroductionBuild your first appOverviewCreate an Android projectRun your appBuild a simple user interfaceStart another activityApp fundamentalsApp resourcesOverviewHandle configuration changesLocalizationLocalize your appTest your app with pseudolocalesUnicode and internationalization supportLanguage and locale resolutionComplex XML resourcesResource typesOverviewAnimationColor state listDrawableLayoutMenuStringStyleFontMore typesApp manifest fileOverview<action><activity><activity-alias><application><category><compatible-screens><data><grant-uri-permission><instrumentation><intent-filter><manifest><meta-data><path-permission><permission><permission-group><permission-tree><provider><receiver><service><supports-gl-texture><supports-screens><uses-configuration><uses-feature><uses-library><uses-permission><uses-permission-sdk-23><uses-sdk>App permissionsOverviewRequest app permissionsApp permissions best practicesDefine custom permissionsDevicesDevice compatibilityOverviewScreen compatibility overviewSupport different screen sizesSupport different pixel densitiesSupport display cutoutsDeclare restricted screen supportMultiple APK supportOverviewCreate multiple APKs for different API levelsCreate multiple APKs for different screen sizesCreate multiple APKs for different GL texturesCreate multiple APKs with several dimensionsSupport different languages and culturesSupport different platform versionsFilters on Google PlayWearOverviewAdding wearable features to notificationsOverviewCreating a notificationNotification stylesBridging mode for notificationsMaintaining compatibilityCreating wearable appsOverviewCreating and running a wearable appStandalone appsCreating custom layoutsKeeping your app visibleAuthentication in WearAdding voice capabilitiesPackaging and distributing Wear appsDebugging a Wear appCapturing Wear UI screenshotsCreating Wear apps for ChinaCreating custom UIsOverviewDefining layoutsCreating listsShowing confirmationsExiting full-screen activitiesUsing the Wear UI libraryWear navigation and actionsMulti-function buttonsRotary inputCreating input method editorsUsing wrist gesturesSending and syncing dataOverviewNetwork access and syncingAccessing the wearable data layerSyncing data itemsTransferring assetsSending and receiving messagesHandling data layer eventsMigrating Wear apps to GoogleApiCreating data providersOverviewExpose data to complicationsCreating watch facesOverviewDesigning watch facesBuilding a watch face serviceDrawing watch facesWatch face complicationsExposing data to complicationsAdding complications to a watch faceCreating interactive watch facesProviding configuration activitiesAddressing common issuesOptimizing watch facesDetecting locationRequesting PermissionsUsing the SpeakerAndroid TVOverviewBuilding TV AppsOverviewGetting started with TV appsHandling TV hardwareManaging TV controllersBuilding TV layoutsCreating TV navigationBuilding TV playback appsOverviewCreating a catalog browserProviding a card viewBuilding a details viewUsing Leanback transport controlsDisplaying a now playing cardAdding a guided stepIntroducing first-time users to your appEnabling background playbackHelping users find content on TVOverviewRecommending TV contentOverviewChannels on the home screenVideo program attributesAudio program attributesGame program attributesWatch next attributesPreviewing videosRecommendations in Android N and earlierMaking TV apps searchableSearching within TV AppsBuilding TV gamesBuilding TV channelsOverviewDeveloping a TV input serviceWorking with channel dataManaging user interactionSupporting time-shiftingSupporting content recordingTV Apps checklistAndroid AutoOverviewGetting Started with AutoPlaying Audio for AutoMessaging for AutoTesting for AutoAndroid ThingsOverviewPlatform differencesGoogle servicesSupported hardwareDeveloper kitsGet startedNXP i.MX7DRaspberry Pi 3Advanced setupOverviewManually flash an imageRecover a deviceConnecting to Wi-Fi with adbBuild appsCreate a Things appOverviewCreate a projectConnect the hardwareInteract with peripheralsIntegrate peripheral driversCommunicate with wireless devicesBluetoothLoWPANConfigure devicesSettingsUpdatesInteract with peripheralsOverviewGPIOPWMI2CSPIUARTNative PIOCLI toolIntegrate native codeBuild user-space driversOverviewLocationInputSensorsLoWPANSamplesManage devicesOverviewCreate a productConfigure a productCreate a buildOverviewManage appsPush an updateOverviewAutomatic updatesMonitor analyticsTermsConsole Terms of ServiceSDK License AgreementAndroid Things ConsoleChrome OS devicesOverviewBuilding apps for Chrome OSPreparing your development environmentOptimizing Apps for Chrome OSResolving Issues with Screen SizeApp Manifest Compatibility for ChromebooksLoading Apps on ChromebooksChrome OS Device Support for AppsApp Rendering Differences on ChromebooksWindow managementInput compatibility for ChromebooksAndroid Studio on Chrome OSChrome OS devices on EmulatorTest Cases for Android Apps on Chrome OSCore topicsActivitiesIntroduction to activitiesThe activity lifecycleActivity state changesTest your activitiesTasks and back stackProcesses and app lifecycleParcelables and bundlesFragmentsOverviewCreate a fragmentTest your fragmentsBuild a flexible UICommunicate with other fragmentsInteract with other appsOverviewSending the user to another appGetting a result from an activityAllowing other apps to start your activityHandling app linksOverviewEnabling links to app contentVerify app linksCreate app links for instant appsLoadersRecents screenMulti-window supportApp shortcutsOverviewCreate shortcutsManage shortcutsBest practices for shortcutsApp widgetsOverviewBuild an app widgetBuild an app widget hostArchitecture ComponentsOverviewAdding Components to your ProjectData Binding LibraryOverviewGet startedLayouts and binding expressionsWork with observable data objectsGenerated binding classesBinding adaptersBind layout views to Architecture ComponentsTwo-way data bindingHandling LifecyclesLiveDataNavigationOverviewImplement NavigationUpdate UI components with NavigationUINested graphsPass data between destinationsAdd support for new destinationImplement conditional navigationCreate a deep link for a destinationGlobal actionsMigrate to the Navigation ComponentPaging LibraryOverviewUI Components and ConsiderationsData Components and ConsiderationsRoom Persistence LibraryViewModelWorkManagerOverviewBasicsAdvancedMigrating from Firebase JobDispatcherSaving StatesRelease notesIntents and intent filtersOverviewCommon intentsUser interface & navigationOverviewLayoutsOverviewBuild a responsive UI with ConstraintLayoutCreate a list with RecyclerViewCreate a card-based layoutImplementing adaptive UI flowsImproving layout performanceOverviewOptimizing layout hierarchiesRe-using layouts with <include/>Delayed loading of viewsMaking ListView scrolling smoothLinear layoutAdapter viewRelative layoutCustom view componentsOverviewCreating a custom view classImplementing custom drawingMaking the view interactiveOptimizing the viewLook and feelMaterial designStyles and themesAdaptive iconsAdd a floating action buttonCreate shadows and clip viewsTextAutosizing TextViewsDownloadable fontsFonts in XMLEmoji compatibilityMagnifier widgetSpansButtonsCheckboxesRadio buttonsToggle buttonsSpinnersPickersTooltipsNotificationsOverviewCreate a notificationCreate an expandable notificationStart an activity from a notificationCreate a group of notificationsCreate and manage notification channelsModify a notification BadgeCreate a custom notificationAdd the app barOverviewSet up the app barAdd and handle actionsAdd an up actionUse action views and action providersControl the system UI visibilityOverviewDim the system barsHide the status barHide the navigation barEnable fullscreen modeRespond to UI visibility changesDesigning effective navigationOverviewPlanning screens and their relationshipsPlanning for multiple touchscreen sizesProviding descendant and lateral navigationDesigning back and up navigationPutting it all together: wireframing the example appImplementing effective navigationOverviewCreating swipe views with tabsCreating a navigation drawerProviding up navigationProviding proper back navigationImplementing descendant navigationSlide between fragments using ViewPagerSupporting swipe-to-refreshOverviewAdding swipe-to-refresh to your appResponding to a refresh gestureToasts overviewPop-up messages overviewOverviewBuild and display a pop-up messageAdd an action to a messageDialogsMenusSettingsOverviewOrganize your settingsCustomize your settingsUse saved valuesBuild a hierarchy in codeHandle other form factorsPreference components and attributesSearchOverviewCreating a search interfaceAdding recent query suggestionsAdding custom suggestionsSearchable configurationAdding search functionalityOverviewSetting up the search interfaceStoring and searching for dataRemaining backward compatibleCopy and pasteDrag and dropCreating backward-compatible UIsOverviewAbstracting the new APIsProxying to the new APIsCreating an implementation with older APIsUsing the version-aware componentAnimations & transitionsOverviewAnimations overviewProperty animation overviewAnimate drawable graphicsReveal or hide a view using animationMove a view using animationMove a view using a fling animationEnlarge a view using a zoom animationAnimate movement using spring physicsAuto animate layout updatesAnimate layout changes using a transitionCreate a custom transition animationStart an activity using an animationImages & graphicsOverviewDrawables overviewVector drawables overviewHandling bitmapsSelecting colors with the palette APIReducing image download sizesHardware accelerationOpenGL ESDisplaying graphics with OpenGL ESOverviewBuilding an OpenGL ES environmentDefining shapesDrawing shapesApplying projection and camera viewsAdding motionResponding to touch eventsRenderingOverviewReducing overdrawPerformance and view hierarchiesAnalyzing with profile GPU renderingEnhancing graphics with wide color contentAudio & videoAudio & video overviewSupported media formatsMedia app architectureMedia app architecture overviewUsing a media sessionBuilding an audio appAudio app overviewBuilding a media browser serviceBuilding a media browser clientMedia session callbacksBuilding a video appVideo app overviewBuilding a video player activityMedia session callbacksResponding to media buttonsHandling changes in audio outputManaging audio focusThe Google Assistant and media appsRouting between devicesRouting overviewMediaRouter overviewMediaRouteProvider overviewControl amplitude with VolumeShaperMediaPlayer overviewMediaRecorder overviewExoPlayerBackground tasksOverviewGuide to background processingSending operations to multiple threadsOverviewSpecify the code to run on a threadCreate a manager for multiple threadsRun code on a thread pool threadCommunicate with the UI threadSchedule jobs intelligentlyServicesOverviewCreate a background serviceSend work requests to the background serviceReport work statusBound servicesAIDL overviewBackground optimizationsBroadcasts overviewImplicit Broadcast ExceptionsManage device awake stateOverviewKeep the device awakeSchedule repeating alarmsApp data & filesOverviewStorage overviewSave files on device storageSave key-value dataSave data in a local databaseOverviewDefine data using entitiesCreate views into a databaseAccess data using DAOsMigrate your databaseTest your databaseReference complex dataSharing simple dataOverviewSending simple data to other appsReceiving simple data from other appsAdding an easy share actionSharing filesOverviewSetting up file sharingSharing a fileRequesting a shared fileRetrieving file informationSharing files with NFCOverviewSending files to another deviceReceiving files from another devicePrinting filesOverviewPrinting photosPrinting HTML documentsPrinting custom documentsContent providersOverviewContent provider basicsCreating a content providerOpen files using storage access frameworkCreate a custom document providerApp install locationUser data & identityOverviewAdd sign-in workflowAutofill frameworkOverviewOptimize your app for autofillBuild autofill servicesCalendar provider overviewContacts providerOverviewRetrieving a list of contactsRetrieving details for a contactModifying contacts using intentsDisplaying the quick contact badgeAccount transferData backupOverviewBack up user dataBack up key-value pairsOverviewRegisterTest backup and restoreBest practices for unique identifiersRemember and authenticate usersOverviewRemember your userAuthenticate to OAuth2 servicesCreate a custom account typeUser locationOverviewOptimize location for batteryGet the last known locationChange location settingsReceive location updatesDisplay a location addressCreate and monitor geofencesDetect when users start an activityMigrate to location and context APIsAdd mapsTouch & inputOverviewInput eventsUsing touch gesturesOverviewDetect common gesturesTrack touch and pointer movementsAnimate a scroll gestureHandle multi-touch gesturesDrag and scaleManage touch events in a ViewGroupHandling keyboard inputOverviewSpecifying the input method typeHandling input method visibilitySupporting keyboard navigationHandling keyboard actionsSupporting game controllersOverviewHandling controller actionsSupporting controllers across Android versionsSupporting multiple game controllersInput method editorsCreating an input methodImage keyboardSpelling checkerCameraOverviewTaking photosRecording videosControlling the cameraCamera APISensorsOverviewSensors overviewMotion sensorsPosition sensorsEnvironment sensorsRaw GNSS measurementsConnectivityOverviewPerforming network operationsOverviewConnect to the networkManage network usageOptimize network data usageParse XML dataTransmit network data using VolleyOverviewSend a simple requestSet up RequestQueueMake a standard requestImplement a custom requestPerform network operations using CronetOverviewSend a simple requestCronet request lifecycleReferenceorg.chromium.netOverviewCallbackExceptionCronetEngineOverviewCronetEngine.BuilderOverviewLibraryLoaderCronetExceptionInlineExecutionProhibitedExceptionNetworkExceptionQuicExceptionUploadDataProviderUploadDataProvidersUploadDataSinkUrlRequestOverviewBuilderCallbackStatusStatusListenerUrlResponseInfoOverviewHeaderBlockTransferring data without draining the batteryOverviewOptimize downloads for efficient network accessMinimize the effect of regular updatesAvoid redundant downloadsModify patterns based on the connectivity typeReduce network battery drainOverviewCollecting network traffic dataAnalyzing data trafficOptimizing user-initiated network useOptimizing app-initiated network useOptimizing server-initiated network useOptimizing general network useTransfer data using Sync AdaptersOverviewCreate a Stub AuthenticatorCreate a Stub Content ProviderCreate a Sync AdapterRun a Sync AdapterBluetoothOverviewBluetooth low energy overviewNFCOverviewNFC basicsAdvanced NFCHost-based card emulation overviewTelecomOverviewBuild a calling appWi-FiWi-Fi scanning overviewWi-Fi peer-to-peer overviewWi-Fi aware overviewWi-Fi location with RTTCompanion device pairing overviewUSBOverviewAccessory overviewHost overviewVPNSession initiation protocol overviewDiscover and connectOverviewUse network service discoveryCreate P2P connections with Wi-FiUse Wi-Fi P2P for service discoveryRenderscriptOverviewAdvanced RenderScriptRuntime API referenceOverviewNumerical typesObject typesConversion functionsMathematical constants and functionsVector math functionsMatrix functionsQuaternion functionsAtomic update functionsTime functions and typesAllocation data access functionsObject characteristics functionsKernel invocation functions and typesInput/output functionsDebugging functionsGraphics functions and typesIndexWeb-based contentOverviewBuilding web apps in WebViewManaging WebView objectsMigrating to WebView in Android 4.4Supporting different screens in web appsDebugging web appsBest practices for web appsAndroid App BundlesOverviewDownload modules with the Play Core LibraryGoogle Play InstantOverview of Google Play InstantGet started with instant appsCreate an instant-enabled app bundleUX best practices for appsGet started with instant gamesOverviewUnity pluginTechnical requirements checklist for gamesUX best practices for gamesReduce the size of your instant app or gameAdd ads to your instant app or gameProvide multiple entry pointsIntegrate with FirebaseAdd Google Analytics for Firebase to your instant appUse Firebase Dynamic Links with instant appsGoogle Play Instant policyResourcesReferenceCode samplesSDK release notesSupportFAQsKnown issuesStackOverflowApp ActionsSlicesOverviewGetting StartedSlice templatesBest practicesTestingOverviewFundamentals of testingSet up projectBuilding effective unit testsOverviewBuilding local unit testsBuilding instrumented unit testsAutomating UI testsOverviewTesting UI for a single appTesting UI for multiple appsTesting app component integrationsOverviewTesting your serviceTesting your content providerTesting UI performanceEspressoOverviewSetup instructionsBasicsRecipesMultiprocessAccessibility checkingListsIntentsWebIdling resourceCheat sheetUI AutomatorJUnit4 RulesAndroidJUnitRunnerSamplesRelease notesPerformanceOverviewAndroid VitalsOverviewStuck Partial Wake LocksExcessive WakeupsExcessive Background Wi-Fi ScansExcessive Background Network UsageANRsCrashesSlow RenderingFrozen FramesPermission DenialsApp Startup TimeApp Standby BucketsProcesses and Threads OverviewBetter Performance through ThreadingOptimizing for Battery LifeOverviewOptimizing for Doze and App StandbyMonitoring the Battery Level and Charging StateDetermining and Monitoring the Docking State and TypeDetermining and Monitoring the Connectivity StatusPower Management RestrictionsAnalyzing Power Use with Battery HistorianTesting power-related issuesReducing APK SizeManage Your App's MemoryOverview of Memory ManagemementDesigning for SeamlessnessKeeping Your App ResponsivePerformance TipsSMP Primer for AndroidVerifying App Behavior on the Android Runtime (ART)AccessibilityOverviewMaking apps more accessibleUsing node tree debuggingBuilding accessibility servicesBuild accessible custom viewsBuild accessibility serviceTest your app's accessibilitySecurityApp security best practicesSecurity tipsSecurity with HTTPS and SSLNetwork security configurationUpdating your security provider to protect against SSL exploitsProtecting against security threats with SafetyNetOverviewSafetyNet Attestation APISafetyNet Safe Browsing APISafetyNet reCAPTCHA APISafetyNet Verify Apps APICryptographyAndroid Keystore SystemVerifying hardware-backed key pairs with key attestationAndroid Protected ConfirmationSupporting Direct BootUsing scoped directory accessApp security improvement programBuild for BillionsOverviewConnectivityDevice capabilityData costBattery consumptionUI and contentBuild for EnterpriseOverviewDeveloper guideWork profilesSet up managed configurationsWork contactsDevice management policiesDevice managementOverviewBuild a device policy controllerWork profiles on fully managed devicesDedicated devicesOverviewLock task modeMultiple usersCookbookDevice controlNetworking and telephonySecuritySystem updatesNetwork activity loggingAndroid versionsOverviewAndroid 9Android 8.0Android 7.0Device administrationGoogle PlayGoogle Play BillingOverviewUse the Google Play Billing LibraryOverviewAdd one-time product-specific featuresAdd subscription-specific featuresPlay Billing Library referencePlay Billing Library release notesUse In-app Billing with AIDLOverviewIn-app Billing ReferenceAdd Real-time Developer NotificationsBest PracticesTest Google Play BillingMaking Your App Content Searchable by GoogleOptimizing Contextual Content for the AssistantGoogle Play Developer APIAPK Expansion FilesApplication LicensingOverviewLicensing OverviewSetting Up for LicensingAdding Licensing to Your AppLicensing ReferenceGoogle Play Install ReferrerOverviewPlay Install Referrer LibraryOverviewReferenceReleases NotesPlay Install Referrer API









    
    
      Android Developers
    
    
    




    
    
      Docs
    
    
    




    
    
      Guides
    
    
    




    Optimize location for battery
  


The Background Location
Limits introduced in
Android 8.0 (API level 26) have brought renewed focus to the subject of how
location services usage affects battery drain. This page addresses some location
services best practices and what you can do now to make your apps more battery
efficient. Applying these best practices benefits your app regardless of the
platform version it is running on.
The background location limits in Android 8.0 introduced the following changes:

Background location gathering is throttled and location is computed, and
delivered only a few times an hour.
Wi-Fi scans are more conservative, and location updates aren't computed when
the device stays connected to the same static access point.
Geofencing responsiveness changes from tens of seconds to approximately two
minutes. This change noticeably improves battery performance—up to 10 times
better on some devices.

This page assumes you’re using the Google Location Services
APIs, which offer higher accuracy and
impose a lighter battery burden than the framework location
APIs. In
particular, this page assumes familiarity with the fused location provider
API,
which combines signals from GPS, Wi-Fi, and cell networks, as well as
accelerometer, gyroscope, magnetometer and other sensors. You should also be
familiar with the geofencing
API, which is built
on top of the fused location provider API, and is optimized for battery
performance.
Understand battery drain
Location gathering and battery drain are directly related in the following
aspects:

Accuracy: The precision of the location data. In general, the higher the
accuracy, the higher the battery drain.
Frequency: How often location is computed. The more frequent location is
computed, the more battery is used.
Latency: How quickly location data is delivered. Less latency usually requires
more battery.

Accuracy
You can specify location accuracy using the
setPriority()
method, passing one of the following values as the argument:

PRIORITY_HIGH_ACCURACY
provides the most accurate location possible, which is computed using as
many inputs as necessary (it enables GPS, Wi-Fi, and cell, and uses a
variety of
Sensors), and may cause
significant battery drain.
PRIORITY_BALANCED_POWER_ACCURACY
provides accurate location while optimizing for power. Very rarely uses
GPS. Typically uses a combination of Wi-Fi and cell information to compute
device location.
PRIORITY_LOW_POWER
largely relies on cell towers and avoids GPS and Wi-Fi inputs, providing
coarse (city-level) accuracy with minimal battery drain.
PRIORITY_NO_POWER
receives locations passively from other apps for which location has
already been computed.

The location needs of most apps can be satisfied using the balanced power or low
power options. High accuracy should be reserved for apps that are running in the
foreground and require real time location updates (for example, a mapping
app).
Frequency
You can specify location frequency using two methods:

Use the
setinterval()
method to specify the interval at which location is computed for your app.
Use the
setFastestInterval()
to specify the interval at which location computed for other apps is
delivered to your app.

You should pass the largest possible value when using setInterval(). This is
especially true for background location gathering, which is often a source of
unwelcome battery drain. Using intervals of a few seconds should be reserved for
foreground use cases. The background location limits introduced in Android 8.0
enforce these strategies, but your app should strive to enforce them on Android
7.0 or lower devices.
Latency
You can specify latency using the
setMaxWaitTime()
method, typically passing a value that is several times larger than the interval
specified in the
setInterval()
method. This setting delays location delivery, and multiple location updates may
be delivered in batches. These two changes help minimize battery consumption.
If your app doesn’t immediately need a location update, you should pass the
largest possible value to the setMaxWaitTime() method, effectively trading
latency for more data and battery efficiency.
When using geofences, apps should pass a large value into the
setNotificationResponsiveness()
method to preserve power. A value of five minutes or larger is recommended.
Location use cases
This section describes some typical location-gathering scenarios, along with
recommendations for optimal use of the geofencing and fused location provider
APIs.
User visible or foreground updates
Example: A mapping app that needs frequent, accurate updates with very low
latency. All updates happen in the foreground: the user starts an activity,
consumes location data, and then stops the activity after a short time.
Use the
setPriority()
method with a value of
PRIORITY_HIGH_ACCURACY
or
PRIORITY_BALANCED_POWER_ACCURACY.
The interval specified in the
setInterval()
method depends on the use case: for real time scenarios, set the value to few
seconds; otherwise, limit to a few minutes (approximately two minutes or
greater is recommended to minimize battery usage).
Knowing the location of the device
Example: A weather app wants to know the device’s location.
Use the
getLastLocation()
method, which returns the most recently available location (which in rare
cases may be null) . This method provides a simple way of getting location and
doesn't incur costs associated with actively requesting location updates. Use
in conjunction with the
isLocationAvailable()
method, which returns true when the location returned by
getLastLocation()
is reasonably up-to-date.
Starting updates when a user is at a specific location
Example: Requesting updates when a user is within a certain distance of
work, home, or another location.
Use geofencing in conjunction with fused location provider updates. Request
updates when the app receives a geofence entrance trigger, and remove updates
when the app receives a geofence exit trigger. This ensures that the app gets
more granular location updates only when the user has entered a defined
area.
The typical workflow for this scenario could involve surfacing a notification
upon the geofence enter transition, and launching an activity which contains
code to request updates when the user taps the notification.
Starting updates based on the user’s activity state
Example: Requesting updates only when the user is driving or riding a
bike.
Use the Activity Recognition
API in
conjunction with fused location provider updates. Request updates when the
targeted activity is detected, and remove updates when the user stops
performing that activity.
The typical workflow for this use case could involve surfacing a
notification for the detected activity, and launching an activity which
contains code to request updates when the user taps the notification.
Long running background location updates tied to geographical areas
Example: The user wants to be notified when the device is within proximity
of a retailer.
This is an excellent use case for geofencing. Because the use case almost
certainly involves background location, use the
addGeofences(GeofencingRequest, PendingIntent)
method.
You should set the following configuration options:

If you're tracking dwell transitions, use the
setLoiteringDelay()
method passing a value of approximately five minutes or less.
Use the
setNotificationResponsiveness(),
passing a value of approximately five minutes. However, consider using a value
of approximately ten minutes if your app can manage the extra delay in
responsiveness.

An app may only register a maximum of 100 geofences at a time. In a use
case where an app wants to track a large number of retailer options, the app
may want to register large geofence (at the city level) and dynamically
register smaller geofences (for locations within the city) for stores within
the larger geofence. When user enters a large geofence, smaller geofences can
be added; when the user exits the larger geofence, the smaller geofences can
be removed and geofences could be re-registered for a new area.
Long running background location updates without a visible app component
Example: An app that passively tracks location
Note: Consider if you really need to collect location in the background, since
this can lead to undesirable battery drain. Also, consider geofencing as an
option, since geofencing APIs are optimized for performance.
Use the
setPriority()
method with the
PRIORITY_NO_POWER
option if possible because it incurs almost no battery drain. If using
PRIORITY_NO_POWER isn't possible, use
PRIORITY_BALANCED_POWER_ACCURACY
or
PRIORITY_LOW_POWER,
but avoid using
PRIORITY_HIGH_ACCURACY
for sustained background work because this option substantially drains
battery.
If you need more location data, use passive location by calling the
setFastestInterval()
method passing a smaller value than what you pass to
setInterval().
When combined with the
PRIORITY_NO_POWER
option, passive location can opportunistically deliver location computed by
other apps at no extra cost.
Moderate frequency by adding some latency, using the
setMaxWaitTime()
method. For example, if you use the setinterval() method with a value of
approximately 10 minutes, you should consider calling setMaxWaitTime() with
a value between 30 to 60 minutes. Using these options, location is computed
for your app approximately every 10 minutes, but the app is only woken up
every 30 to 60 minutes with some location data available as a batch update. This
approach trades latency for more data available and better battery
performance.
Frequent high accuracy updates while the user interacts with other apps
Example: A navigation or fitness app that continues to work when the user
either turns off the screen or opens a different app.
Use a foreground service. If expensive work is potentially going to be done
by your app on behalf of the user, making the user aware of that work is a
recommended best practice. A foreground service requires a persistent
notification. For more information, see Notifications
Overview.
Location best practices
Implementing the best practices in this section help reduce the battery usage of
your app.
Remove location updates
A common source of unnecessary battery drain is the failure to remove location
updates when they are no longer needed. This can happen, for example, when an
activity’s onStart() or
onResume() lifecycle
methods contain a call to
requestlocationUpdates()
without a corresponding call to
removeLocationUpdates()
in the onPause() or
onStop() lifecycle methods.
You can use lifecycle-aware components to better manage the lifecycle of the
activities in your app. For more information, see Handling Lifecycles with
Lifecycle-Aware Components.
Set timeouts
To guard against battery drain, set a reasonable timeout when location updates
should stop. The timeout ensures that updates don't continue indefinitely, and
it protects the app in scenarios where updates are requested but not removed
(for example, because of a bug in the code).
For a fused location provider request, add a timeout by calling
setExpirationDuration(),
which receives a parameter that represents the time in milliseconds since the
method was last called. You can also add a timeout by calling
setExpirationTime(),
which receives a parameter that represents the expiration time in milliseconds
since the system last boot.
To add a timeout to a geofence location request, call the
setExpirationDuration()
method.
Batch requests
For all non-foreground use cases, batch multiple requests together. You can use
the
setInterval()
method to specify the interval at which you would like location to be computed.
Then, use the
setMaxWaitTime()
method to set the interval at which location is delivered to your app. The
value passed to the setMaxWaitTime() method should be a multiple of the value
passed to the setInterval() method. For example, consider the following
location request:

Kotlin

val request = LocationRequest()
request.setInterval(10 * 60 * 1000)
request.setMaxWaitTime(60 * 60 * 1000)

Java

LocationRequest request = new LocationRequest();
request.setInterval(10 * 60 * 1000);
request.setMaxWaitTime(60 * 60 * 1000);



In this case, location is computed roughly every ten minutes, and approximately
six location data points are delivered in a batch approximately every hour.
While you still get location updates every ten minutes or so, you conserve
battery because your device is woken up only every hour or so.
Use passive location updates
In background use cases, it is a good idea to throttle location updates. Android
8.0 limits enforce this practice, but apps running on older devices should
strive to limit background location as much as possible.
It is likely that while your app is in the background, another app may be
frequently requesting location updates in the foreground. Location services
makes these updates available to your app. Consider the following location
request, which opportunistically consumes location data:

Kotlin

val request = LocationRequest()
request.setInterval(15 * 60 * 1000)
request.setFastestInterval(2 * 60 * 1000)

Java

LocationRequest request = new LocationRequest();
request.setInterval(15 * 60 * 1000);
request.setFastestInterval(2 * 60 * 1000);



In the previous example, location is computed for your app roughly every 15
minutes. If other apps request location, the data is made available to your app
at a maximum interval of two minutes.
While consuming location passively incurs no battery drain, take extra care in
cases where the receipt of location data triggers expensive CPU or I/O
operations. To minimize battery costs, the interval specified in
setFastestInterval()
shouldn't be too small.
You can significantly improve the battery performance of your users' devices by
following the recommendations on this page. Your users are less likely to delete
apps that don't drain their battery.





        
        Next
      


          arrow_forward
        
        Get the last known location
      




Content and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates.

      
      Last updated January 17, 2019.
    





          
          
            Twitter
          
        Follow @AndroidDev on Twitter
          
          
            YouTube
          
        Check out Android Developers on YouTubeMore Android
                Android
            
                Enterprise
            
                Security
            
                Source
            Support
                Report platform bug
            
                Report documentation bug
            
                Google Play support
            
                Join user studies
            Documentation
                Developer guides
            
                Design guides
            
                API reference
            
                Samples
            
                Android Studio
            
                Android
            
                Chrome
            
                Firebase
            
                Google Cloud Platform
            
                All Products
            
            Bahasa Indonesia
          
            Deutsch
          
            English
          
            español
          
            Español (América Latina)
          
            français
          
            Português Brasileiro
          
            Tiếng Việt
          
            Türkçe
          
            Русский
          
            ภาษาไทย
          
            日本語
          
            简体中文
          
            繁體中文
          
            한국어
          Privacy
         License
         Brand Guidelines
         
        Get Android and Google Play news by email
      
        
        Subscribe
      
