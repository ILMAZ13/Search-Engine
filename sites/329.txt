Understand Tasks and Back Stack  |  Android DevelopersAndroid Developers
          Platform
        
          Android Studio
        
          Google Play
        
          Android Jetpack
        
          Docs
        
          News
        
    
    
    
      Documentation
    
    
  
          Overview
        
          Guides
        
          Reference
        
          Samples
        
          Design & Quality
        







          Platform
        



          Android Studio
        



          Google Play
        



          Android Jetpack
        



          Docs
        




          Overview
        



          Guides
        



          Reference
        



          Samples
        



          Design & Quality
        






          News
        












App BasicsIntroductionBuild your first appOverviewCreate an Android projectRun your appBuild a simple user interfaceStart another activityApp fundamentalsApp resourcesOverviewHandle configuration changesLocalizationLocalize your appTest your app with pseudolocalesUnicode and internationalization supportLanguage and locale resolutionComplex XML resourcesResource typesOverviewAnimationColor state listDrawableLayoutMenuStringStyleFontMore typesApp manifest fileOverview<action><activity><activity-alias><application><category><compatible-screens><data><grant-uri-permission><instrumentation><intent-filter><manifest><meta-data><path-permission><permission><permission-group><permission-tree><provider><receiver><service><supports-gl-texture><supports-screens><uses-configuration><uses-feature><uses-library><uses-permission><uses-permission-sdk-23><uses-sdk>App permissionsOverviewRequest app permissionsApp permissions best practicesDefine custom permissionsDevicesDevice compatibilityOverviewScreen compatibility overviewSupport different screen sizesSupport different pixel densitiesSupport display cutoutsDeclare restricted screen supportMultiple APK supportOverviewCreate multiple APKs for different API levelsCreate multiple APKs for different screen sizesCreate multiple APKs for different GL texturesCreate multiple APKs with several dimensionsSupport different languages and culturesSupport different platform versionsFilters on Google PlayWearOverviewAdding wearable features to notificationsOverviewCreating a notificationNotification stylesBridging mode for notificationsMaintaining compatibilityCreating wearable appsOverviewCreating and running a wearable appStandalone appsCreating custom layoutsKeeping your app visibleAuthentication in WearAdding voice capabilitiesPackaging and distributing Wear appsDebugging a Wear appCapturing Wear UI screenshotsCreating Wear apps for ChinaCreating custom UIsOverviewDefining layoutsCreating listsShowing confirmationsExiting full-screen activitiesUsing the Wear UI libraryWear navigation and actionsMulti-function buttonsRotary inputCreating input method editorsUsing wrist gesturesSending and syncing dataOverviewNetwork access and syncingAccessing the wearable data layerSyncing data itemsTransferring assetsSending and receiving messagesHandling data layer eventsMigrating Wear apps to GoogleApiCreating data providersOverviewExpose data to complicationsCreating watch facesOverviewDesigning watch facesBuilding a watch face serviceDrawing watch facesWatch face complicationsExposing data to complicationsAdding complications to a watch faceCreating interactive watch facesProviding configuration activitiesAddressing common issuesOptimizing watch facesDetecting locationRequesting PermissionsUsing the SpeakerAndroid TVOverviewBuilding TV AppsOverviewGetting started with TV appsHandling TV hardwareManaging TV controllersBuilding TV layoutsCreating TV navigationBuilding TV playback appsOverviewCreating a catalog browserProviding a card viewBuilding a details viewUsing Leanback transport controlsDisplaying a now playing cardAdding a guided stepIntroducing first-time users to your appEnabling background playbackHelping users find content on TVOverviewRecommending TV contentOverviewChannels on the home screenVideo program attributesAudio program attributesGame program attributesWatch next attributesPreviewing videosRecommendations in Android N and earlierMaking TV apps searchableSearching within TV AppsBuilding TV gamesBuilding TV channelsOverviewDeveloping a TV input serviceWorking with channel dataManaging user interactionSupporting time-shiftingSupporting content recordingTV Apps checklistAndroid AutoOverviewGetting Started with AutoPlaying Audio for AutoMessaging for AutoTesting for AutoAndroid ThingsOverviewPlatform differencesGoogle servicesSupported hardwareDeveloper kitsGet startedNXP i.MX7DRaspberry Pi 3Advanced setupOverviewManually flash an imageRecover a deviceConnecting to Wi-Fi with adbBuild appsCreate a Things appOverviewCreate a projectConnect the hardwareInteract with peripheralsIntegrate peripheral driversCommunicate with wireless devicesBluetoothLoWPANConfigure devicesSettingsUpdatesInteract with peripheralsOverviewGPIOPWMI2CSPIUARTNative PIOCLI toolIntegrate native codeBuild user-space driversOverviewLocationInputSensorsLoWPANSamplesManage devicesOverviewCreate a productConfigure a productCreate a buildOverviewManage appsPush an updateOverviewAutomatic updatesMonitor analyticsTermsConsole Terms of ServiceSDK License AgreementAndroid Things ConsoleChrome OS devicesOverviewBuilding apps for Chrome OSPreparing your development environmentOptimizing Apps for Chrome OSResolving Issues with Screen SizeApp Manifest Compatibility for ChromebooksLoading Apps on ChromebooksChrome OS Device Support for AppsApp Rendering Differences on ChromebooksWindow managementInput compatibility for ChromebooksAndroid Studio on Chrome OSChrome OS devices on EmulatorTest Cases for Android Apps on Chrome OSCore topicsActivitiesIntroduction to activitiesThe activity lifecycleActivity state changesTest your activitiesTasks and back stackProcesses and app lifecycleParcelables and bundlesFragmentsOverviewCreate a fragmentTest your fragmentsBuild a flexible UICommunicate with other fragmentsInteract with other appsOverviewSending the user to another appGetting a result from an activityAllowing other apps to start your activityHandling app linksOverviewEnabling links to app contentVerify app linksCreate app links for instant appsLoadersRecents screenMulti-window supportApp shortcutsOverviewCreate shortcutsManage shortcutsBest practices for shortcutsApp widgetsOverviewBuild an app widgetBuild an app widget hostArchitecture ComponentsOverviewAdding Components to your ProjectData Binding LibraryOverviewGet startedLayouts and binding expressionsWork with observable data objectsGenerated binding classesBinding adaptersBind layout views to Architecture ComponentsTwo-way data bindingHandling LifecyclesLiveDataNavigationOverviewImplement NavigationUpdate UI components with NavigationUINested graphsPass data between destinationsAdd support for new destinationImplement conditional navigationCreate a deep link for a destinationGlobal actionsMigrate to the Navigation ComponentPaging LibraryOverviewUI Components and ConsiderationsData Components and ConsiderationsRoom Persistence LibraryViewModelWorkManagerOverviewBasicsAdvancedMigrating from Firebase JobDispatcherSaving StatesRelease notesIntents and intent filtersOverviewCommon intentsUser interface & navigationOverviewLayoutsOverviewBuild a responsive UI with ConstraintLayoutCreate a list with RecyclerViewCreate a card-based layoutImplementing adaptive UI flowsImproving layout performanceOverviewOptimizing layout hierarchiesRe-using layouts with <include/>Delayed loading of viewsMaking ListView scrolling smoothLinear layoutAdapter viewRelative layoutCustom view componentsOverviewCreating a custom view classImplementing custom drawingMaking the view interactiveOptimizing the viewLook and feelMaterial designStyles and themesAdaptive iconsAdd a floating action buttonCreate shadows and clip viewsTextAutosizing TextViewsDownloadable fontsFonts in XMLEmoji compatibilityMagnifier widgetSpansButtonsCheckboxesRadio buttonsToggle buttonsSpinnersPickersTooltipsNotificationsOverviewCreate a notificationCreate an expandable notificationStart an activity from a notificationCreate a group of notificationsCreate and manage notification channelsModify a notification BadgeCreate a custom notificationAdd the app barOverviewSet up the app barAdd and handle actionsAdd an up actionUse action views and action providersControl the system UI visibilityOverviewDim the system barsHide the status barHide the navigation barEnable fullscreen modeRespond to UI visibility changesDesigning effective navigationOverviewPlanning screens and their relationshipsPlanning for multiple touchscreen sizesProviding descendant and lateral navigationDesigning back and up navigationPutting it all together: wireframing the example appImplementing effective navigationOverviewCreating swipe views with tabsCreating a navigation drawerProviding up navigationProviding proper back navigationImplementing descendant navigationSlide between fragments using ViewPagerSupporting swipe-to-refreshOverviewAdding swipe-to-refresh to your appResponding to a refresh gestureToasts overviewPop-up messages overviewOverviewBuild and display a pop-up messageAdd an action to a messageDialogsMenusSettingsOverviewOrganize your settingsCustomize your settingsUse saved valuesBuild a hierarchy in codeHandle other form factorsPreference components and attributesSearchOverviewCreating a search interfaceAdding recent query suggestionsAdding custom suggestionsSearchable configurationAdding search functionalityOverviewSetting up the search interfaceStoring and searching for dataRemaining backward compatibleCopy and pasteDrag and dropCreating backward-compatible UIsOverviewAbstracting the new APIsProxying to the new APIsCreating an implementation with older APIsUsing the version-aware componentAnimations & transitionsOverviewAnimations overviewProperty animation overviewAnimate drawable graphicsReveal or hide a view using animationMove a view using animationMove a view using a fling animationEnlarge a view using a zoom animationAnimate movement using spring physicsAuto animate layout updatesAnimate layout changes using a transitionCreate a custom transition animationStart an activity using an animationImages & graphicsOverviewDrawables overviewVector drawables overviewHandling bitmapsSelecting colors with the palette APIReducing image download sizesHardware accelerationOpenGL ESDisplaying graphics with OpenGL ESOverviewBuilding an OpenGL ES environmentDefining shapesDrawing shapesApplying projection and camera viewsAdding motionResponding to touch eventsRenderingOverviewReducing overdrawPerformance and view hierarchiesAnalyzing with profile GPU renderingEnhancing graphics with wide color contentAudio & videoAudio & video overviewSupported media formatsMedia app architectureMedia app architecture overviewUsing a media sessionBuilding an audio appAudio app overviewBuilding a media browser serviceBuilding a media browser clientMedia session callbacksBuilding a video appVideo app overviewBuilding a video player activityMedia session callbacksResponding to media buttonsHandling changes in audio outputManaging audio focusThe Google Assistant and media appsRouting between devicesRouting overviewMediaRouter overviewMediaRouteProvider overviewControl amplitude with VolumeShaperMediaPlayer overviewMediaRecorder overviewExoPlayerBackground tasksOverviewGuide to background processingSending operations to multiple threadsOverviewSpecify the code to run on a threadCreate a manager for multiple threadsRun code on a thread pool threadCommunicate with the UI threadSchedule jobs intelligentlyServicesOverviewCreate a background serviceSend work requests to the background serviceReport work statusBound servicesAIDL overviewBackground optimizationsBroadcasts overviewImplicit Broadcast ExceptionsManage device awake stateOverviewKeep the device awakeSchedule repeating alarmsApp data & filesOverviewStorage overviewSave files on device storageSave key-value dataSave data in a local databaseOverviewDefine data using entitiesCreate views into a databaseAccess data using DAOsMigrate your databaseTest your databaseReference complex dataSharing simple dataOverviewSending simple data to other appsReceiving simple data from other appsAdding an easy share actionSharing filesOverviewSetting up file sharingSharing a fileRequesting a shared fileRetrieving file informationSharing files with NFCOverviewSending files to another deviceReceiving files from another devicePrinting filesOverviewPrinting photosPrinting HTML documentsPrinting custom documentsContent providersOverviewContent provider basicsCreating a content providerOpen files using storage access frameworkCreate a custom document providerApp install locationUser data & identityOverviewAdd sign-in workflowAutofill frameworkOverviewOptimize your app for autofillBuild autofill servicesCalendar provider overviewContacts providerOverviewRetrieving a list of contactsRetrieving details for a contactModifying contacts using intentsDisplaying the quick contact badgeAccount transferData backupOverviewBack up user dataBack up key-value pairsOverviewRegisterTest backup and restoreBest practices for unique identifiersRemember and authenticate usersOverviewRemember your userAuthenticate to OAuth2 servicesCreate a custom account typeUser locationOverviewOptimize location for batteryGet the last known locationChange location settingsReceive location updatesDisplay a location addressCreate and monitor geofencesDetect when users start an activityMigrate to location and context APIsAdd mapsTouch & inputOverviewInput eventsUsing touch gesturesOverviewDetect common gesturesTrack touch and pointer movementsAnimate a scroll gestureHandle multi-touch gesturesDrag and scaleManage touch events in a ViewGroupHandling keyboard inputOverviewSpecifying the input method typeHandling input method visibilitySupporting keyboard navigationHandling keyboard actionsSupporting game controllersOverviewHandling controller actionsSupporting controllers across Android versionsSupporting multiple game controllersInput method editorsCreating an input methodImage keyboardSpelling checkerCameraOverviewTaking photosRecording videosControlling the cameraCamera APISensorsOverviewSensors overviewMotion sensorsPosition sensorsEnvironment sensorsRaw GNSS measurementsConnectivityOverviewPerforming network operationsOverviewConnect to the networkManage network usageOptimize network data usageParse XML dataTransmit network data using VolleyOverviewSend a simple requestSet up RequestQueueMake a standard requestImplement a custom requestPerform network operations using CronetOverviewSend a simple requestCronet request lifecycleReferenceorg.chromium.netOverviewCallbackExceptionCronetEngineOverviewCronetEngine.BuilderOverviewLibraryLoaderCronetExceptionInlineExecutionProhibitedExceptionNetworkExceptionQuicExceptionUploadDataProviderUploadDataProvidersUploadDataSinkUrlRequestOverviewBuilderCallbackStatusStatusListenerUrlResponseInfoOverviewHeaderBlockTransferring data without draining the batteryOverviewOptimize downloads for efficient network accessMinimize the effect of regular updatesAvoid redundant downloadsModify patterns based on the connectivity typeReduce network battery drainOverviewCollecting network traffic dataAnalyzing data trafficOptimizing user-initiated network useOptimizing app-initiated network useOptimizing server-initiated network useOptimizing general network useTransfer data using Sync AdaptersOverviewCreate a Stub AuthenticatorCreate a Stub Content ProviderCreate a Sync AdapterRun a Sync AdapterBluetoothOverviewBluetooth low energy overviewNFCOverviewNFC basicsAdvanced NFCHost-based card emulation overviewTelecomOverviewBuild a calling appWi-FiWi-Fi scanning overviewWi-Fi peer-to-peer overviewWi-Fi aware overviewWi-Fi location with RTTCompanion device pairing overviewUSBOverviewAccessory overviewHost overviewVPNSession initiation protocol overviewDiscover and connectOverviewUse network service discoveryCreate P2P connections with Wi-FiUse Wi-Fi P2P for service discoveryRenderscriptOverviewAdvanced RenderScriptRuntime API referenceOverviewNumerical typesObject typesConversion functionsMathematical constants and functionsVector math functionsMatrix functionsQuaternion functionsAtomic update functionsTime functions and typesAllocation data access functionsObject characteristics functionsKernel invocation functions and typesInput/output functionsDebugging functionsGraphics functions and typesIndexWeb-based contentOverviewBuilding web apps in WebViewManaging WebView objectsMigrating to WebView in Android 4.4Supporting different screens in web appsDebugging web appsBest practices for web appsAndroid App BundlesOverviewDownload modules with the Play Core LibraryGoogle Play InstantOverview of Google Play InstantGet started with instant appsCreate an instant-enabled app bundleUX best practices for appsGet started with instant gamesOverviewUnity pluginTechnical requirements checklist for gamesUX best practices for gamesReduce the size of your instant app or gameAdd ads to your instant app or gameProvide multiple entry pointsIntegrate with FirebaseAdd Google Analytics for Firebase to your instant appUse Firebase Dynamic Links with instant appsGoogle Play Instant policyResourcesReferenceCode samplesSDK release notesSupportFAQsKnown issuesStackOverflowApp ActionsSlicesOverviewGetting StartedSlice templatesBest practicesTestingOverviewFundamentals of testingSet up projectBuilding effective unit testsOverviewBuilding local unit testsBuilding instrumented unit testsAutomating UI testsOverviewTesting UI for a single appTesting UI for multiple appsTesting app component integrationsOverviewTesting your serviceTesting your content providerTesting UI performanceEspressoOverviewSetup instructionsBasicsRecipesMultiprocessAccessibility checkingListsIntentsWebIdling resourceCheat sheetUI AutomatorJUnit4 RulesAndroidJUnitRunnerSamplesRelease notesPerformanceOverviewAndroid VitalsOverviewStuck Partial Wake LocksExcessive WakeupsExcessive Background Wi-Fi ScansExcessive Background Network UsageANRsCrashesSlow RenderingFrozen FramesPermission DenialsApp Startup TimeApp Standby BucketsProcesses and Threads OverviewBetter Performance through ThreadingOptimizing for Battery LifeOverviewOptimizing for Doze and App StandbyMonitoring the Battery Level and Charging StateDetermining and Monitoring the Docking State and TypeDetermining and Monitoring the Connectivity StatusPower Management RestrictionsAnalyzing Power Use with Battery HistorianTesting power-related issuesReducing APK SizeManage Your App's MemoryOverview of Memory ManagemementDesigning for SeamlessnessKeeping Your App ResponsivePerformance TipsSMP Primer for AndroidVerifying App Behavior on the Android Runtime (ART)AccessibilityOverviewMaking apps more accessibleUsing node tree debuggingBuilding accessibility servicesBuild accessible custom viewsBuild accessibility serviceTest your app's accessibilitySecurityApp security best practicesSecurity tipsSecurity with HTTPS and SSLNetwork security configurationUpdating your security provider to protect against SSL exploitsProtecting against security threats with SafetyNetOverviewSafetyNet Attestation APISafetyNet Safe Browsing APISafetyNet reCAPTCHA APISafetyNet Verify Apps APICryptographyAndroid Keystore SystemVerifying hardware-backed key pairs with key attestationAndroid Protected ConfirmationSupporting Direct BootUsing scoped directory accessApp security improvement programBuild for BillionsOverviewConnectivityDevice capabilityData costBattery consumptionUI and contentBuild for EnterpriseOverviewDeveloper guideWork profilesSet up managed configurationsWork contactsDevice management policiesDevice managementOverviewBuild a device policy controllerWork profiles on fully managed devicesDedicated devicesOverviewLock task modeMultiple usersCookbookDevice controlNetworking and telephonySecuritySystem updatesNetwork activity loggingAndroid versionsOverviewAndroid 9Android 8.0Android 7.0Device administrationGoogle PlayGoogle Play BillingOverviewUse the Google Play Billing LibraryOverviewAdd one-time product-specific featuresAdd subscription-specific featuresPlay Billing Library referencePlay Billing Library release notesUse In-app Billing with AIDLOverviewIn-app Billing ReferenceAdd Real-time Developer NotificationsBest PracticesTest Google Play BillingMaking Your App Content Searchable by GoogleOptimizing Contextual Content for the AssistantGoogle Play Developer APIAPK Expansion FilesApplication LicensingOverviewLicensing OverviewSetting Up for LicensingAdding Licensing to Your AppLicensing ReferenceGoogle Play Install ReferrerOverviewPlay Install Referrer LibraryOverviewReferenceReleases NotesPlay Install Referrer API









    
    
      Android Developers
    
    
    




    
    
      Docs
    
    
    




    
    
      Guides
    
    
    




    Understand Tasks and Back Stack
  


A task is a collection of activities that users interact with
when performing a certain job. The activities are arranged in a stack—the back stack)—in
the order in which each activity is opened.
For example, an email app might have one activity to show a list of new messages.
When the user selects a message, a new activity opens to view that message. This new activity
is added to the back stack. If the user presses the Back button, that new activity is
finished and popped off the stack. The following video provides a good overview of how the back
stack works.




When apps are running simultaneously in a
multi-windowed environment, supported in
Android 7.0 (API level 24) and higher, the system manages tasks separately for each window;
each window may have multiple tasks. The same holds true for 
Android apps running on Chromebooks: the system manages tasks, or groups of tasks, on a
per-window basis.
The device Home screen is the starting place for most tasks. When the user touches an icon in the
app
launcher (or a shortcut on the Home screen), that app's task comes to the foreground. If no
task exists for the app (the app has not been used recently), then a new task
is created and the "main" activity for that app opens as the root activity in the stack.
When the current activity starts another, the new activity is pushed on the top of the stack and
takes focus. The previous activity remains in the stack, but is stopped. When an activity
stops, the system retains the current state of its user interface. When the user presses the
Back
button, the current activity is popped from the top of the stack (the activity is destroyed) and the
previous activity resumes (the previous state of its UI is restored). Activities in the stack are
never rearranged, only pushed and popped from the stack—pushed onto the stack when started by
the current activity and popped off when the user leaves it using the Back button. As such,
the back
stack operates as a "last in, first out" object structure. Figure 1 visualizes
this behavior with a timeline showing the progress between activities along with the current back
stack at each point in time.

Figure 1. A representation of how each new activity in a
task adds an item to the back stack. When the user presses the Back button, the current
activity is
destroyed and the previous activity resumes.
If the user continues to press Back, then each activity in the stack is popped off to
reveal the
previous one, until the user returns to the Home screen (or to whichever activity was running when
the task began). When all activities are removed from the stack, the task no longer exists.

 Figure 2. Two tasks: Task B receives user interaction
in the foreground, while Task A is in the background, waiting to be resumed.

A task is a cohesive unit that can move to the "background" when users begin a new task or go
to the Home screen, via the Home button. While in the background, all the activities in the
task are
stopped, but the back stack for the task remains intact—the task has simply lost focus while
another task takes place, as shown in figure 2. A task can then return to the "foreground" so users
can pick up where they left off. Suppose, for example, that the current task (Task A) has three
activities in its stack—two under the current activity. The user presses the Home
button, then
starts a new app from the app launcher. When the Home screen appears, Task A goes
into the background. When the new app starts, the system starts a task for that app
(Task B) with its own stack of activities. After interacting with
that app, the user returns Home again and selects the app that originally
started Task A. Now, Task A comes to the
foreground—all three activities in its stack are intact and the activity at the top of the
stack resumes. At
this point, the user can also switch back to Task B by going Home and selecting the app icon
that started that task (or by selecting the app's task from the
Recents screen).
This is an example of multitasking on Android.
Note: Multiple tasks can be held in the background at once.
However, if the user is running many background tasks at the same time, the system might begin
destroying background activities in order to recover memory, causing the activity states to be lost.


 Figure 3. A single activity is instantiated multiple times.

Because the activities in the back stack are never rearranged, if your app allows
users to start a particular activity from more than one activity, a new instance of
that activity is created and pushed onto the stack (rather than bringing any previous instance of
the activity to the top). As such, one activity in your app might be instantiated multiple
times (even from different tasks), as shown in figure 3. As such, if the user navigates backward
using the Back button, each instance of the activity is revealed in the order they were
opened (each
with their own UI state). However, you can modify this behavior if you do not want an activity to be
instantiated more than once. How to do so is discussed in the later section about Managing Tasks.
To summarize the default behavior for activities and tasks:

When Activity A starts Activity B, Activity A is stopped, but the system retains its state
(such as scroll position and text entered into forms).
If the user presses the Back button while in Activity B, Activity A resumes with its state
restored.
When the user leaves a task by pressing the Home button, the current activity is
stopped and
its task goes into the background. The system retains the state of every activity in the task. If
the user later resumes the task by selecting the launcher icon that began the task, the task comes
to the foreground and resumes the activity at the top of the stack.
If the user presses the Back button, the current activity is popped from the stack
and
destroyed. The previous activity in the stack is resumed. When an activity is destroyed, the system
does not retain the activity's state.
Activities can be instantiated multiple times, even from other tasks.


Navigation Design
For more about how app navigation works on Android, read Android Design's Navigation guide.

Managing Tasks
The way Android manages tasks and the back stack, as described above—by placing all
activities started in succession in the same task and in a "last in, first out" stack—works
great for most apps and you shouldn't have to worry about how your activities are associated
with tasks or how they exist in the back stack. However, you might decide that you want to interrupt
the normal behavior. Perhaps you want an activity in your app to begin a new task when it is
started (instead of being placed within the current task); or, when you start an activity, you want
to bring forward an existing instance of it (instead of creating a new
instance on top of the back stack); or, you want your back stack to be cleared of all
activities except for the root activity when the user leaves the task.
You can do these things and more, with attributes in the
<activity>
manifest element and with flags in the intent that you pass to
startActivity().
In this regard, the principal 
<activity> attributes you can use are:


taskAffinity

launchMode

allowTaskReparenting

clearTaskOnLaunch

alwaysRetainTaskState

finishOnTaskLaunch

And the principal intent flags you can use are:

FLAG_ACTIVITY_NEW_TASK
FLAG_ACTIVITY_CLEAR_TOP
FLAG_ACTIVITY_SINGLE_TOP

In the following sections, you'll see how you can use these manifest attributes and intent
flags to define how activities are associated with tasks and how they behave in the back stack.
Also, discussed separately are the considerations for how tasks and activities may be represented
and managed in the Recents screen. See Recents Screen
for more information. Normally you should allow the system to define how your task and
activities are represented in the Recents screen, and you don't need to modify this behavior.
Caution: Most apps should not interrupt the default
behavior for activities and tasks. If you determine that it's necessary for your activity to modify
the default behaviors, use caution and be sure to test the usability of the activity during
launch and when navigating back to it from other activities and tasks with the Back button.
Be sure to test for navigation behaviors that might conflict with the user's expected behavior.
Defining launch modes
Launch modes allow you to define how a new instance of an activity is associated with the
current task. You can define different launch modes in two ways:

Using the manifest file
When you declare an activity in your manifest file, you can specify how the activity
should associate with tasks when it starts.
Using Intent flags
When you call startActivity(),
you can include a flag in the Intent that declares how (or
whether) the new activity should associate with the current task.

As such, if Activity A starts Activity B, Activity B can define in its manifest how it
should associate with the current task (if at all) and Activity A can also request how Activity
B should associate with current task. If both activities define how Activity B
should associate with a task, then Activity A's request (as defined in the intent) is honored
over Activity B's request (as defined in its manifest).
Note: Some launch modes available for the manifest file
are not available as flags for an intent and, likewise, some launch modes available as flags
for an intent cannot be defined in the manifest.
Using the manifest file
When declaring an activity in your manifest file, you can specify how the activity should
associate with a task using the <activity>
element's launchMode attribute.
The launchMode attribute specifies an instruction on how the activity should be launched into a
task. There are four different launch modes you can assign to the
launchMode
attribute:

"standard" (the default mode)
Default. The system creates a new instance of the activity in the task from
which it was started and routes the intent to it. The activity can be instantiated multiple times,
each instance can belong to different tasks, and one task can have multiple instances.
"singleTop"
If an instance of the activity already exists at the top of the current task, the system
routes the intent to that instance through a call to its onNewIntent() method, rather than creating a new instance of the
activity. The activity can be instantiated multiple times, each instance can
belong to different tasks, and one task can have multiple instances (but only if the
activity at the top of the back stack is not an existing instance of the activity).
  For example, suppose a task's back stack consists of root activity A with activities B, C,
and D on top (the stack is A-B-C-D; D is on top). An intent arrives for an activity of type D.
If D has the default "standard" launch mode, a new instance of the class is launched and the
stack becomes A-B-C-D-D. However, if D's launch mode is "singleTop", the existing instance
of D receives the intent through onNewIntent(), because it's at the top of the stack—the
stack remains A-B-C-D. However, if an intent arrives for an activity of type B, then a new
instance of B is added to the stack, even if its launch mode is "singleTop".
Note: When a new instance of an activity is created,
the user can press the Back button to return to the previous activity. But when an existing
instance of
an activity handles a new intent, the user cannot press the Back button to return to the
state of
the activity before the new intent arrived in onNewIntent().

"singleTask"
The system creates a new task and instantiates the activity at the root of the new task.
However, if an instance of the activity already exists in a separate task, the system routes the
intent to the existing instance through a call to its
    onNewIntent() method, rather than creating
    a new instance. Only one instance of the activity can exist at a time.
  Note: Although the activity starts in a new task, the
Back button still returns the user to the previous activity.
"singleInstance".
Same as "singleTask", except that the system doesn't launch any other activities into
the task holding the instance. The activity is always the single and only member of its task;
any activities started by this one open in a separate task.

As another example, the Android Browser app declares that the web browser activity should
always open in its own task—by specifying the singleTask launch mode in the <activity> element.
This means that if your app issues an
intent to open the Android Browser, its activity is not placed in the same
task as your app. Instead, either a new task starts for the Browser or, if the Browser
already has a task running in the background, that task is brought forward to handle the new
intent.
Regardless of whether an activity starts in a new task or in the same task as the activity that
started it, the Back button always takes the user to the previous activity. However, if you
start an activity that specifies the singleTask launch mode, then if an instance of
that activity exists in a background task, that whole task is brought to the foreground. At this
point, the back stack now includes all activities from the task brought forward, at the top of the
stack. Figure 4 illustrates this type of scenario.

Figure 4. A representation of how an activity with
launch mode "singleTask" is added to the back stack. If the activity is already a part of a
background task with its own back stack, then the entire back stack also comes
forward, on top of the current task.
For more information about using launch modes in the manifest file, see the
<activity>
element documentation, where the launchMode attribute and the accepted values are
discussed more.
Note: The behaviors that you specify for your activity with the launchMode attribute
can be overridden by flags included with the intent that start your activity, as discussed in the
next section.
Using Intent flags
When starting an activity, you can modify the default association of an activity to its task
by including flags in the intent that you deliver to startActivity(). The flags you can use to modify the
default behavior are:

FLAG_ACTIVITY_NEW_TASK
Start the activity in a new task. If a task is already running for the activity you are now
starting, that task is brought to the foreground with its last state restored and the activity
receives the new intent in onNewIntent().
    This produces the same behavior as the "singleTask" launchMode value,
discussed in the previous section.
FLAG_ACTIVITY_SINGLE_TOP
If the activity being started is the current activity (at the top of the back stack), then
the existing instance receives a call to onNewIntent(),
instead of creating a new instance of the activity.
    This produces the same behavior as the "singleTop" launchMode value,
discussed in the previous section.
FLAG_ACTIVITY_CLEAR_TOP
If the activity being started is already running in the current task, then instead
of launching a new instance of that activity, all of the other activities on top of it are
destroyed and this intent is delivered to the resumed instance of the activity (now on top),
through onNewIntent()).
    There is no value for the launchMode
attribute that produces this behavior.
FLAG_ACTIVITY_CLEAR_TOP is most often used in conjunction with
    FLAG_ACTIVITY_NEW_TASK.
When used together, these flags are a way of locating an existing activity
in another task and putting it in a position where it can respond to the intent. 
Note: If the launch mode of the designated activity is
    "standard",
it too is removed from the stack and a new instance is launched in its place to handle
the incoming intent.  That's because a new instance is always created for a new intent when the
launch mode is "standard". 


Handling affinities
The affinity indicates which task an activity prefers to belong to. By default, all the
activities from the same app have an affinity for each other. So, by default, all
activities in the same app prefer to be in the same task. However, you can modify
the default affinity for an activity. Activities defined in
different apps can share an affinity, or activities defined in the same app can be
assigned different task affinities.
You can modify the affinity for any given activity with the taskAffinity attribute
of the <activity>
element.
The taskAffinity
attribute takes a string value, which must be unique from the default package name
declared in the 
<manifest>
 element, because the system uses that name to identify the default task
affinity for the app.
The affinity comes into play in two circumstances:

When the intent that launches an activity contains the
  FLAG_ACTIVITY_NEW_TASK
  flag.

A new activity is, by default, launched into the task of the activity
that called startActivity(). It's pushed onto the same
back stack as the caller.  However, if the intent passed to
startActivity()
contains the FLAG_ACTIVITY_NEW_TASK
flag, the system looks for a different task to house the new activity. Often, it's a new task.
However, it doesn't have to be.  If there's already an existing task with the same affinity as the
new activity, the activity is launched into that task.  If not, it begins a new task.
If this flag causes an activity to begin a new task and the user presses the Home button
to leave
it, there must be some way for the user to navigate back to the task. Some entities (such as the
notification manager) always start activities in an external task, never as part of their own, so
they always put FLAG_ACTIVITY_NEW_TASK in the intents they pass to
startActivity().
If you have an activity that can be invoked by
an external entity that might use this flag, take care that the user has a independent way to get
back to the task that's started, such as with a launcher icon (the root activity of the task
has a CATEGORY_LAUNCHER intent filter; see the Starting a task section below).

When an activity has its 
allowTaskReparenting attribute set to "true".
  In this case, the activity can move from the task it starts to the task it has an affinity
for, when that task comes to the foreground.
For example, suppose that an activity that reports weather conditions in selected cities is
defined as part of a travel app.  It has the same affinity as other activities in the same
app (the default app affinity) and it allows re-parenting with this attribute.
When one of your activities starts the weather reporter activity, it initially belongs to the same
task as your activity. However, when the travel app's task comes to the foreground, the
weather reporter activity is reassigned to that task and displayed within it.


Tip: If an APK file contains more than one "app"
from the user's point of view, you probably want to use the taskAffinity
attribute to assign different affinities to the activities associated with each "app".
Clearing the back stack
If the user leaves a task for a long time, the system clears the task of all activities except
the root activity.  When the user returns to the task again, only the root activity is restored.
The system behaves this way, because, after an extended amount of time, users likely have abandoned
what they were doing before and are returning to the task to begin something new. 
There are some activity attributes that you can use to modify this behavior: 

alwaysRetainTaskState

If this attribute is set to "true" in the root activity of a task,
the default behavior just described does not happen.
The task retains all activities in its stack even after a long period.
clearTaskOnLaunch
If this attribute is set to "true" in the root activity of a task,
the stack is cleared down to the root activity whenever the user leaves the task
and returns to it.  In other words, it's the opposite of

alwaysRetainTaskState. The user always returns to the task in its
initial state, even after a leaving the task for only a moment.
finishOnTaskLaunch

This attribute is like clearTaskOnLaunch,
but it operates on a
single activity, not an entire task.  It can also cause any activity to go
away, including the root activity.  When it's set to "true", the
activity remains part of the task only for the current session.  If the user
leaves and then returns to the task, it is no longer present.

Starting a task
You can set up an activity as the entry point for a task by giving it an intent filter with
"android.intent.action.MAIN" as the specified action and
"android.intent.category.LAUNCHER"
as the specified category. For example:

<activity ... >
    <intent-filter ... >
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
    ...
</activity>

An intent filter of this kind causes an icon and label for the
activity to be displayed in the app launcher, giving users a way to launch the activity and
to return to the task that it creates any time after it has been launched.

This second ability is important: Users must be able to leave a task and then come back to it
later using this activity launcher. For this reason, the two launch modes
that mark activities as always initiating a task, "singleTask" and
"singleInstance", should be used only when the activity has an
ACTION_MAIN
and a CATEGORY_LAUNCHER filter. Imagine, for example, what could
happen if the filter is missing: An intent launches a "singleTask" activity, initiating a
new task, and the user spends some time working in that task. The user then presses the Home
button. The task is now sent to the background and is not visible. Now the user has no way to return
to the task, because it is not represented in the app launcher.
For those cases where you don't want the user to be able to return to an activity, set the
<activity>
element's
finishOnTaskLaunch
to "true" (see Clearing the back stack).
Further information about how tasks and activities are represented and managed in
the Overview screen is available in 
Recents Screen.
More resources

Android Design:
Navigation
<activity> manifest
element
Recents Screen

  Multitasking the Android Way



Content and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates.

      
      Last updated January 17, 2019.
    





          
          
            Twitter
          
        Follow @AndroidDev on Twitter
          
          
            YouTube
          
        Check out Android Developers on YouTubeMore Android
                Android
            
                Enterprise
            
                Security
            
                Source
            Support
                Report platform bug
            
                Report documentation bug
            
                Google Play support
            
                Join user studies
            Documentation
                Developer guides
            
                Design guides
            
                API reference
            
                Samples
            
                Android Studio
            
                Android
            
                Chrome
            
                Firebase
            
                Google Cloud Platform
            
                All Products
            
            Bahasa Indonesia
          
            Deutsch
          
            English
          
            español
          
            Español (América Latina)
          
            français
          
            Português Brasileiro
          
            Tiếng Việt
          
            Türkçe
          
            Русский
          
            ภาษาไทย
          
            日本語
          
            简体中文
          
            繁體中文
          
            한국어
          Privacy
         License
         Brand Guidelines
         
        Get Android and Google Play news by email
      
        
        Subscribe
      
