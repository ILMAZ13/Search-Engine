Custom View Components  |  Android DevelopersAndroid Developers
          Platform
        
          Android Studio
        
          Google Play
        
          Android Jetpack
        
          Docs
        
          News
        
    
    
    
      Documentation
    
    
  
          Overview
        
          Guides
        
          Reference
        
          Samples
        
          Design & Quality
        







          Platform
        



          Android Studio
        



          Google Play
        



          Android Jetpack
        



          Docs
        




          Overview
        



          Guides
        



          Reference
        



          Samples
        



          Design & Quality
        






          News
        












App BasicsIntroductionBuild your first appOverviewCreate an Android projectRun your appBuild a simple user interfaceStart another activityApp fundamentalsApp resourcesOverviewHandle configuration changesLocalizationLocalize your appTest your app with pseudolocalesUnicode and internationalization supportLanguage and locale resolutionComplex XML resourcesResource typesOverviewAnimationColor state listDrawableLayoutMenuStringStyleFontMore typesApp manifest fileOverview<action><activity><activity-alias><application><category><compatible-screens><data><grant-uri-permission><instrumentation><intent-filter><manifest><meta-data><path-permission><permission><permission-group><permission-tree><provider><receiver><service><supports-gl-texture><supports-screens><uses-configuration><uses-feature><uses-library><uses-permission><uses-permission-sdk-23><uses-sdk>App permissionsOverviewRequest app permissionsApp permissions best practicesDefine custom permissionsDevicesDevice compatibilityOverviewScreen compatibility overviewSupport different screen sizesSupport different pixel densitiesSupport display cutoutsDeclare restricted screen supportMultiple APK supportOverviewCreate multiple APKs for different API levelsCreate multiple APKs for different screen sizesCreate multiple APKs for different GL texturesCreate multiple APKs with several dimensionsSupport different languages and culturesSupport different platform versionsFilters on Google PlayWearOverviewAdding wearable features to notificationsOverviewCreating a notificationNotification stylesBridging mode for notificationsMaintaining compatibilityCreating wearable appsOverviewCreating and running a wearable appStandalone appsCreating custom layoutsKeeping your app visibleAuthentication in WearAdding voice capabilitiesPackaging and distributing Wear appsDebugging a Wear appCapturing Wear UI screenshotsCreating Wear apps for ChinaCreating custom UIsOverviewDefining layoutsCreating listsShowing confirmationsExiting full-screen activitiesUsing the Wear UI libraryWear navigation and actionsMulti-function buttonsRotary inputCreating input method editorsUsing wrist gesturesSending and syncing dataOverviewNetwork access and syncingAccessing the wearable data layerSyncing data itemsTransferring assetsSending and receiving messagesHandling data layer eventsMigrating Wear apps to GoogleApiCreating data providersOverviewExpose data to complicationsCreating watch facesOverviewDesigning watch facesBuilding a watch face serviceDrawing watch facesWatch face complicationsExposing data to complicationsAdding complications to a watch faceCreating interactive watch facesProviding configuration activitiesAddressing common issuesOptimizing watch facesDetecting locationRequesting PermissionsUsing the SpeakerAndroid TVOverviewBuilding TV AppsOverviewGetting started with TV appsHandling TV hardwareManaging TV controllersBuilding TV layoutsCreating TV navigationBuilding TV playback appsOverviewCreating a catalog browserProviding a card viewBuilding a details viewUsing Leanback transport controlsDisplaying a now playing cardAdding a guided stepIntroducing first-time users to your appEnabling background playbackHelping users find content on TVOverviewRecommending TV contentOverviewChannels on the home screenVideo program attributesAudio program attributesGame program attributesWatch next attributesPreviewing videosRecommendations in Android N and earlierMaking TV apps searchableSearching within TV AppsBuilding TV gamesBuilding TV channelsOverviewDeveloping a TV input serviceWorking with channel dataManaging user interactionSupporting time-shiftingSupporting content recordingTV Apps checklistAndroid AutoOverviewGetting Started with AutoPlaying Audio for AutoMessaging for AutoTesting for AutoAndroid ThingsOverviewPlatform differencesGoogle servicesSupported hardwareDeveloper kitsGet startedNXP i.MX7DRaspberry Pi 3Advanced setupOverviewManually flash an imageRecover a deviceConnecting to Wi-Fi with adbBuild appsCreate a Things appOverviewCreate a projectConnect the hardwareInteract with peripheralsIntegrate peripheral driversCommunicate with wireless devicesBluetoothLoWPANConfigure devicesSettingsUpdatesInteract with peripheralsOverviewGPIOPWMI2CSPIUARTNative PIOCLI toolIntegrate native codeBuild user-space driversOverviewLocationInputSensorsLoWPANSamplesManage devicesOverviewCreate a productConfigure a productCreate a buildOverviewManage appsPush an updateOverviewAutomatic updatesMonitor analyticsTermsConsole Terms of ServiceSDK License AgreementAndroid Things ConsoleChrome OS devicesOverviewBuilding apps for Chrome OSPreparing your development environmentOptimizing Apps for Chrome OSResolving Issues with Screen SizeApp Manifest Compatibility for ChromebooksLoading Apps on ChromebooksChrome OS Device Support for AppsApp Rendering Differences on ChromebooksWindow managementInput compatibility for ChromebooksAndroid Studio on Chrome OSChrome OS devices on EmulatorTest Cases for Android Apps on Chrome OSCore topicsActivitiesIntroduction to activitiesThe activity lifecycleActivity state changesTest your activitiesTasks and back stackProcesses and app lifecycleParcelables and bundlesFragmentsOverviewCreate a fragmentTest your fragmentsBuild a flexible UICommunicate with other fragmentsInteract with other appsOverviewSending the user to another appGetting a result from an activityAllowing other apps to start your activityHandling app linksOverviewEnabling links to app contentVerify app linksCreate app links for instant appsLoadersRecents screenMulti-window supportApp shortcutsOverviewCreate shortcutsManage shortcutsBest practices for shortcutsApp widgetsOverviewBuild an app widgetBuild an app widget hostArchitecture ComponentsOverviewAdding Components to your ProjectData Binding LibraryOverviewGet startedLayouts and binding expressionsWork with observable data objectsGenerated binding classesBinding adaptersBind layout views to Architecture ComponentsTwo-way data bindingHandling LifecyclesLiveDataNavigationOverviewImplement NavigationUpdate UI components with NavigationUINested graphsPass data between destinationsAdd support for new destinationImplement conditional navigationCreate a deep link for a destinationGlobal actionsMigrate to the Navigation ComponentPaging LibraryOverviewUI Components and ConsiderationsData Components and ConsiderationsRoom Persistence LibraryViewModelWorkManagerOverviewBasicsAdvancedMigrating from Firebase JobDispatcherSaving StatesRelease notesIntents and intent filtersOverviewCommon intentsUser interface & navigationOverviewLayoutsOverviewBuild a responsive UI with ConstraintLayoutCreate a list with RecyclerViewCreate a card-based layoutImplementing adaptive UI flowsImproving layout performanceOverviewOptimizing layout hierarchiesRe-using layouts with <include/>Delayed loading of viewsMaking ListView scrolling smoothLinear layoutAdapter viewRelative layoutCustom view componentsOverviewCreating a custom view classImplementing custom drawingMaking the view interactiveOptimizing the viewLook and feelMaterial designStyles and themesAdaptive iconsAdd a floating action buttonCreate shadows and clip viewsTextAutosizing TextViewsDownloadable fontsFonts in XMLEmoji compatibilityMagnifier widgetSpansButtonsCheckboxesRadio buttonsToggle buttonsSpinnersPickersTooltipsNotificationsOverviewCreate a notificationCreate an expandable notificationStart an activity from a notificationCreate a group of notificationsCreate and manage notification channelsModify a notification BadgeCreate a custom notificationAdd the app barOverviewSet up the app barAdd and handle actionsAdd an up actionUse action views and action providersControl the system UI visibilityOverviewDim the system barsHide the status barHide the navigation barEnable fullscreen modeRespond to UI visibility changesDesigning effective navigationOverviewPlanning screens and their relationshipsPlanning for multiple touchscreen sizesProviding descendant and lateral navigationDesigning back and up navigationPutting it all together: wireframing the example appImplementing effective navigationOverviewCreating swipe views with tabsCreating a navigation drawerProviding up navigationProviding proper back navigationImplementing descendant navigationSlide between fragments using ViewPagerSupporting swipe-to-refreshOverviewAdding swipe-to-refresh to your appResponding to a refresh gestureToasts overviewPop-up messages overviewOverviewBuild and display a pop-up messageAdd an action to a messageDialogsMenusSettingsOverviewOrganize your settingsCustomize your settingsUse saved valuesBuild a hierarchy in codeHandle other form factorsPreference components and attributesSearchOverviewCreating a search interfaceAdding recent query suggestionsAdding custom suggestionsSearchable configurationAdding search functionalityOverviewSetting up the search interfaceStoring and searching for dataRemaining backward compatibleCopy and pasteDrag and dropCreating backward-compatible UIsOverviewAbstracting the new APIsProxying to the new APIsCreating an implementation with older APIsUsing the version-aware componentAnimations & transitionsOverviewAnimations overviewProperty animation overviewAnimate drawable graphicsReveal or hide a view using animationMove a view using animationMove a view using a fling animationEnlarge a view using a zoom animationAnimate movement using spring physicsAuto animate layout updatesAnimate layout changes using a transitionCreate a custom transition animationStart an activity using an animationImages & graphicsOverviewDrawables overviewVector drawables overviewHandling bitmapsSelecting colors with the palette APIReducing image download sizesHardware accelerationOpenGL ESDisplaying graphics with OpenGL ESOverviewBuilding an OpenGL ES environmentDefining shapesDrawing shapesApplying projection and camera viewsAdding motionResponding to touch eventsRenderingOverviewReducing overdrawPerformance and view hierarchiesAnalyzing with profile GPU renderingEnhancing graphics with wide color contentAudio & videoAudio & video overviewSupported media formatsMedia app architectureMedia app architecture overviewUsing a media sessionBuilding an audio appAudio app overviewBuilding a media browser serviceBuilding a media browser clientMedia session callbacksBuilding a video appVideo app overviewBuilding a video player activityMedia session callbacksResponding to media buttonsHandling changes in audio outputManaging audio focusThe Google Assistant and media appsRouting between devicesRouting overviewMediaRouter overviewMediaRouteProvider overviewControl amplitude with VolumeShaperMediaPlayer overviewMediaRecorder overviewExoPlayerBackground tasksOverviewGuide to background processingSending operations to multiple threadsOverviewSpecify the code to run on a threadCreate a manager for multiple threadsRun code on a thread pool threadCommunicate with the UI threadSchedule jobs intelligentlyServicesOverviewCreate a background serviceSend work requests to the background serviceReport work statusBound servicesAIDL overviewBackground optimizationsBroadcasts overviewImplicit Broadcast ExceptionsManage device awake stateOverviewKeep the device awakeSchedule repeating alarmsApp data & filesOverviewStorage overviewSave files on device storageSave key-value dataSave data in a local databaseOverviewDefine data using entitiesCreate views into a databaseAccess data using DAOsMigrate your databaseTest your databaseReference complex dataSharing simple dataOverviewSending simple data to other appsReceiving simple data from other appsAdding an easy share actionSharing filesOverviewSetting up file sharingSharing a fileRequesting a shared fileRetrieving file informationSharing files with NFCOverviewSending files to another deviceReceiving files from another devicePrinting filesOverviewPrinting photosPrinting HTML documentsPrinting custom documentsContent providersOverviewContent provider basicsCreating a content providerOpen files using storage access frameworkCreate a custom document providerApp install locationUser data & identityOverviewAdd sign-in workflowAutofill frameworkOverviewOptimize your app for autofillBuild autofill servicesCalendar provider overviewContacts providerOverviewRetrieving a list of contactsRetrieving details for a contactModifying contacts using intentsDisplaying the quick contact badgeAccount transferData backupOverviewBack up user dataBack up key-value pairsOverviewRegisterTest backup and restoreBest practices for unique identifiersRemember and authenticate usersOverviewRemember your userAuthenticate to OAuth2 servicesCreate a custom account typeUser locationOverviewOptimize location for batteryGet the last known locationChange location settingsReceive location updatesDisplay a location addressCreate and monitor geofencesDetect when users start an activityMigrate to location and context APIsAdd mapsTouch & inputOverviewInput eventsUsing touch gesturesOverviewDetect common gesturesTrack touch and pointer movementsAnimate a scroll gestureHandle multi-touch gesturesDrag and scaleManage touch events in a ViewGroupHandling keyboard inputOverviewSpecifying the input method typeHandling input method visibilitySupporting keyboard navigationHandling keyboard actionsSupporting game controllersOverviewHandling controller actionsSupporting controllers across Android versionsSupporting multiple game controllersInput method editorsCreating an input methodImage keyboardSpelling checkerCameraOverviewTaking photosRecording videosControlling the cameraCamera APISensorsOverviewSensors overviewMotion sensorsPosition sensorsEnvironment sensorsRaw GNSS measurementsConnectivityOverviewPerforming network operationsOverviewConnect to the networkManage network usageOptimize network data usageParse XML dataTransmit network data using VolleyOverviewSend a simple requestSet up RequestQueueMake a standard requestImplement a custom requestPerform network operations using CronetOverviewSend a simple requestCronet request lifecycleReferenceorg.chromium.netOverviewCallbackExceptionCronetEngineOverviewCronetEngine.BuilderOverviewLibraryLoaderCronetExceptionInlineExecutionProhibitedExceptionNetworkExceptionQuicExceptionUploadDataProviderUploadDataProvidersUploadDataSinkUrlRequestOverviewBuilderCallbackStatusStatusListenerUrlResponseInfoOverviewHeaderBlockTransferring data without draining the batteryOverviewOptimize downloads for efficient network accessMinimize the effect of regular updatesAvoid redundant downloadsModify patterns based on the connectivity typeReduce network battery drainOverviewCollecting network traffic dataAnalyzing data trafficOptimizing user-initiated network useOptimizing app-initiated network useOptimizing server-initiated network useOptimizing general network useTransfer data using Sync AdaptersOverviewCreate a Stub AuthenticatorCreate a Stub Content ProviderCreate a Sync AdapterRun a Sync AdapterBluetoothOverviewBluetooth low energy overviewNFCOverviewNFC basicsAdvanced NFCHost-based card emulation overviewTelecomOverviewBuild a calling appWi-FiWi-Fi scanning overviewWi-Fi peer-to-peer overviewWi-Fi aware overviewWi-Fi location with RTTCompanion device pairing overviewUSBOverviewAccessory overviewHost overviewVPNSession initiation protocol overviewDiscover and connectOverviewUse network service discoveryCreate P2P connections with Wi-FiUse Wi-Fi P2P for service discoveryRenderscriptOverviewAdvanced RenderScriptRuntime API referenceOverviewNumerical typesObject typesConversion functionsMathematical constants and functionsVector math functionsMatrix functionsQuaternion functionsAtomic update functionsTime functions and typesAllocation data access functionsObject characteristics functionsKernel invocation functions and typesInput/output functionsDebugging functionsGraphics functions and typesIndexWeb-based contentOverviewBuilding web apps in WebViewManaging WebView objectsMigrating to WebView in Android 4.4Supporting different screens in web appsDebugging web appsBest practices for web appsAndroid App BundlesOverviewDownload modules with the Play Core LibraryGoogle Play InstantOverview of Google Play InstantGet started with instant appsCreate an instant-enabled app bundleUX best practices for appsGet started with instant gamesOverviewUnity pluginTechnical requirements checklist for gamesUX best practices for gamesReduce the size of your instant app or gameAdd ads to your instant app or gameProvide multiple entry pointsIntegrate with FirebaseAdd Google Analytics for Firebase to your instant appUse Firebase Dynamic Links with instant appsGoogle Play Instant policyResourcesReferenceCode samplesSDK release notesSupportFAQsKnown issuesStackOverflowApp ActionsSlicesOverviewGetting StartedSlice templatesBest practicesTestingOverviewFundamentals of testingSet up projectBuilding effective unit testsOverviewBuilding local unit testsBuilding instrumented unit testsAutomating UI testsOverviewTesting UI for a single appTesting UI for multiple appsTesting app component integrationsOverviewTesting your serviceTesting your content providerTesting UI performanceEspressoOverviewSetup instructionsBasicsRecipesMultiprocessAccessibility checkingListsIntentsWebIdling resourceCheat sheetUI AutomatorJUnit4 RulesAndroidJUnitRunnerSamplesRelease notesPerformanceOverviewAndroid VitalsOverviewStuck Partial Wake LocksExcessive WakeupsExcessive Background Wi-Fi ScansExcessive Background Network UsageANRsCrashesSlow RenderingFrozen FramesPermission DenialsApp Startup TimeApp Standby BucketsProcesses and Threads OverviewBetter Performance through ThreadingOptimizing for Battery LifeOverviewOptimizing for Doze and App StandbyMonitoring the Battery Level and Charging StateDetermining and Monitoring the Docking State and TypeDetermining and Monitoring the Connectivity StatusPower Management RestrictionsAnalyzing Power Use with Battery HistorianTesting power-related issuesReducing APK SizeManage Your App's MemoryOverview of Memory ManagemementDesigning for SeamlessnessKeeping Your App ResponsivePerformance TipsSMP Primer for AndroidVerifying App Behavior on the Android Runtime (ART)AccessibilityOverviewMaking apps more accessibleUsing node tree debuggingBuilding accessibility servicesBuild accessible custom viewsBuild accessibility serviceTest your app's accessibilitySecurityApp security best practicesSecurity tipsSecurity with HTTPS and SSLNetwork security configurationUpdating your security provider to protect against SSL exploitsProtecting against security threats with SafetyNetOverviewSafetyNet Attestation APISafetyNet Safe Browsing APISafetyNet reCAPTCHA APISafetyNet Verify Apps APICryptographyAndroid Keystore SystemVerifying hardware-backed key pairs with key attestationAndroid Protected ConfirmationSupporting Direct BootUsing scoped directory accessApp security improvement programBuild for BillionsOverviewConnectivityDevice capabilityData costBattery consumptionUI and contentBuild for EnterpriseOverviewDeveloper guideWork profilesSet up managed configurationsWork contactsDevice management policiesDevice managementOverviewBuild a device policy controllerWork profiles on fully managed devicesDedicated devicesOverviewLock task modeMultiple usersCookbookDevice controlNetworking and telephonySecuritySystem updatesNetwork activity loggingAndroid versionsOverviewAndroid 9Android 8.0Android 7.0Device administrationGoogle PlayGoogle Play BillingOverviewUse the Google Play Billing LibraryOverviewAdd one-time product-specific featuresAdd subscription-specific featuresPlay Billing Library referencePlay Billing Library release notesUse In-app Billing with AIDLOverviewIn-app Billing ReferenceAdd Real-time Developer NotificationsBest PracticesTest Google Play BillingMaking Your App Content Searchable by GoogleOptimizing Contextual Content for the AssistantGoogle Play Developer APIAPK Expansion FilesApplication LicensingOverviewLicensing OverviewSetting Up for LicensingAdding Licensing to Your AppLicensing ReferenceGoogle Play Install ReferrerOverviewPlay Install Referrer LibraryOverviewReferenceReleases NotesPlay Install Referrer API









    
    
      Android Developers
    
    
    




    
    
      Docs
    
    
    




    
    
      Guides
    
    
    




    Custom View Components
  


Android offers a sophisticated and powerful componentized model for building your UI,
based on the fundamental layout classes: View and
ViewGroup. To start with, the platform includes a variety of prebuilt
View and ViewGroup subclasses — called widgets and layouts, respectively —
that you can use to construct your UI.
A partial list of available widgets includes Button,
TextView,
EditText,
ListView,
CheckBox,
RadioButton,
Gallery,
Spinner, and the more special-purpose
AutoCompleteTextView,
ImageSwitcher, and
TextSwitcher. 
Among the layouts available are LinearLayout,
FrameLayout, RelativeLayout,
and others. For more examples, see Common Layout Objects.
If none of the prebuilt widgets or layouts meets your needs, you can create your own View subclass.
If you only need to make small adjustments to an existing widget or layout, you can simply subclass
the widget or layout and override its methods.

Creating your own View subclasses gives you precise control over the appearance and function
of a screen element. To give an idea of the control you get with custom views, here are some
examples of what you could do with them:


    You could create a completely custom-rendered View type, for example a "volume
    control" knob rendered using 2D graphics, and which resembles an
    analog electronic control.
  

    You could combine a group of View components into a new single component, perhaps
    to make something like a ComboBox (a combination of popup list and free
    entry text field), a dual-pane selector control (a left and right pane
    with a list in each where you can reassign which item is in which
    list), and so on.
  

    You could override the way that an EditText component is rendered on the screen
    (the 
      Notepad Tutorial uses this to good effect to create a lined notepad page).
  

    You could capture other events like key presses and handle them in some custom
    way (such as for a game).
  


The sections below explain how to create custom Views and use them in your application.
For detailed reference information, see the View class. 
The Basic Approach
Here is a high level overview of what you need to know to get started in creating your own
View components:


    Extend an existing View class or subclass
	with your own class.
  

    Override some of the methods from the superclass. The superclass methods
    to override start with 'on', for
    example, onDraw(),
    onMeasure(), and
    onKeyDown().
    This is similar to the on... events in Activity
    or ListActivity
    that you override for lifecycle and other functionality hooks.
  
    Use your new extension class. Once completed, your new extension class
    can be used in place of the view upon which it was based.
  

Tip:
    Extension classes can be defined as inner classes inside the activities
    that use them. This is useful because it controls access to them but
    isn't necessary (perhaps you want to create a new public View for
    wider use in your application).

Fully Customized Components

Fully customized components can be used to create graphical components that
appear however you wish. Perhaps a graphical VU
meter that looks like an old analog gauge, or a sing-a-long text view where
a bouncing ball moves along the words so you can sing along with a karaoke
machine. Either way, you want something that the built-in components just
won't do, no matter how you combine them.
Fortunately, you can easily create components that look and behave in any
way you like, limited perhaps only by your imagination, the size of the
screen, and the available processing power (remember that ultimately your
application might have to run on something with significantly less power
than your desktop workstation).
To create a fully customized component:


    The most generic view you can extend is, unsurprisingly, View, so you will usually start by extending this to
    create your new super component.
  

    You can supply a constructor which can
    take attributes and parameters from the XML, and you can also consume
    your own such attributes and parameters (perhaps the color and range of
    the VU meter, or the width and damping of the needle, etc.)
  

    You will probably want to create your own event listeners,
    property accessors and modifiers, and possibly more sophisticated
    behavior in your component class as well.
  

    You will almost certainly want to override onMeasure() and
    are also likely to need to override onDraw() if you want
    the component to show something. While both have default behavior,
    the default onDraw() will do nothing, and the default
    onMeasure() will always set a size of 100x100 — which is
    probably not what you want.
  

    Other on... methods may also be overridden as required.
  

Extend onDraw() and onMeasure()
The onDraw() method delivers you a Canvas
upon which you can implement anything you want: 2D graphics, other standard or
custom components, styled text, or anything else you can think of.
Note:
This does not apply to 3D graphics. If you want to
use 3D graphics, you must extend SurfaceView
instead of View, and draw from a separate thread. See the
GLSurfaceViewActivity sample
for details.
onMeasure() is a little more involved. onMeasure()
is a critical piece of the rendering contract between your component and its
container. onMeasure() should be overridden to efficiently and
accurately report the measurements of its contained parts. This is made
slightly more complex by the requirements of limits from the parent
(which are passed in to the onMeasure() method) and by the
requirement to call the setMeasuredDimension() method with the
measured width and height once they have been calculated. If you fail to
call this method from an overridden onMeasure() method, the
result will be an exception at measurement time.
At a high level, implementing onMeasure() looks something
 like this:


    The overridden onMeasure() method is called with width and
    height measure specifications (widthMeasureSpec and
    heightMeasureSpec parameters, both are integer codes
    representing dimensions) which should be treated as requirements for
    the restrictions on the width and height measurements you should produce. A
    full reference to the kind of restrictions these specifications can require
    can be found in the reference documentation under View.onMeasure(int, int) (this reference
    documentation does a pretty good job of explaining the whole measurement
    operation as well).
  

    Your component's onMeasure() method should calculate a
    measurement width and height which will be required to render the
    component. It should try to stay within the specifications passed in,
    although it can choose to exceed them (in this case, the parent can
    choose what to do, including clipping, scrolling, throwing an exception,
    or asking the onMeasure() to try again, perhaps with
    different measurement specifications).
  

    Once the width and height are calculated, the setMeasuredDimension(int
    width, int height) method must be called with the calculated
    measurements. Failure to do this will result in an exception being
    thrown.
  


Here's a summary of some of the other standard methods that the framework calls on views:



Category Methods Description



Creation
Constructors
There is a form of the constructor that are called when the view
           is created from code and a form that is called when the view is
           inflated from a layout file. The second form should parse and apply
           any attributes defined in the layout file.
           


onFinishInflate()
Called after a view and all of its children has been inflated
           from XML.


Layout
onMeasure(int, int)
Called to determine the size requirements for this view and all
           of its children.
           


onLayout(boolean, int, int, int, int)
Called when this view should assign a size and position to all
           of its children.
           


onSizeChanged(int, int, int, int)
Called when the size of this view has changed.
           


Drawing
onDraw(Canvas)
Called when the view should render its content.
           


Event processing
onKeyDown(int, KeyEvent)
Called when a new key event occurs.
           


onKeyUp(int, KeyEvent)
Called when a key up event occurs.
           


onTrackballEvent(MotionEvent)
Called when a trackball motion event occurs.
           


onTouchEvent(MotionEvent)
Called when a touch screen motion event occurs.
           


Focus
onFocusChanged(boolean, int, Rect)
Called when the view gains or loses focus.
           


onWindowFocusChanged(boolean)
Called when the window containing the view gains or loses focus.
           


Attaching
onAttachedToWindow()
Called when the view is attached to a window.
           


onDetachedFromWindow()
Called when the view is detached from its window.
           


onWindowVisibilityChanged(int)
Called when the visibility of the window containing the view
           has changed.
           



Compound Controls

If you don't want to create a completely customized component, but instead
are looking to put together a reusable component that consists of a group of
existing controls, then creating a Compound Component (or Compound Control) might
fit the bill. In a nutshell, this brings together a number of more atomic
controls (or views) into a logical group of items that can be treated as a
single thing. For example, a Combo Box can be thought of as a
combination of a single line EditText field and an adjacent button with an attached
 PopupList. If you press the button and select
something from the list, it populates the EditText field, but the user can
also type something directly into the EditText if they prefer.
In Android, there are actually two other Views readily available to do
this: Spinner and
AutoCompleteTextView, but
regardless, the concept of a Combo Box makes an easy-to-understand
example.
To create a compound component:


    The usual starting point is a Layout of some kind, so create a class
    that extends a Layout. Perhaps in the case of a Combo box we might use
    a LinearLayout with horizontal orientation. Remember that other layouts
    can be nested inside, so the compound component can be arbitrarily
    complex and structured. Note that just like with an Activity, you can
    use either the declarative (XML-based) approach to creating the
    contained components, or you can nest them programmatically from your
    code.
  

    In the constructor for the new class, take whatever parameters the
    superclass expects, and pass them through to the superclass constructor
    first. Then you can set up the other views to use within your new
    component; this is where you would create the EditText field and the
    PopupList. Note that you also might introduce your own attributes and
    parameters into the XML that can be pulled out and used by your
    constructor.
  

    You can also create listeners for events that your contained views might
    generate, for example, a listener method for the List Item Click Listener
    to update the contents of the EditText if a list selection is made.
  

    You might also create your own properties with accessors and modifiers,
    for example, allow the EditText value to be set initially in the
    component and query for its contents when needed.
  

    In the case of extending a Layout, you don't need to override the
    onDraw() and onMeasure() methods since the
    layout will have default behavior that will likely work just fine. However,
    you can still override them if you need to.
  

    You might override other on... methods, like
    onKeyDown(), to perhaps choose certain default values from
    the popup list of a combo box when a certain key is pressed.
  


 To summarize, the use of a Layout as the basis for a Custom Control has a
number of advantages, including:


    You can specify the layout using the declarative XML files just like
    with an activity screen, or you can create views programmatically and
    nest them into the layout from your code.
  

    The onDraw() and onMeasure() methods (plus
    most of the other on... methods) will likely have suitable behavior so
    you don't have to override them.
  

    In the end, you can very quickly construct arbitrarily complex compound
    views and re-use them as if they were a single component.
  

Modifying an Existing View Type
There is an even easier option for creating a custom View which is
useful in certain circumstances. If there is a component that is already very
similar to what you want, you can simply extend that component and just
override the behavior that you want to change. You can do all of the things
you would do with a fully customized component, but by starting with a more
specialized class in the View hierarchy, you can also get a lot of behavior for
free that probably does exactly what you want.
As an example, the 
  NotePad application demonstrates many aspects of using the Android platform. Among
  them is extending an EditText View to make a lined notepad. This is not a perfect example, and
  the APIs for doing this might change, but it does demonstrate the principles.
If you haven't done so already, import the NotePad sample into Android Studio (or
just look at the source using the link provided). In particular, note the definition of
LinedEditText in the
  
    NoteEditor.java file.
Here are some things to note in this file:


The Definition
The class is defined with the following line:
public static class LinedEditText extends EditText


LinedEditText is defined as an inner class within the NoteEditor
        activity, but it is public so that it could be accessed as
        NoteEditor.LinedEditText from outside of the NoteEditor
        class if desired.

        It is static, meaning it does not generate the so-called
        "synthetic methods" that allow it to access data from the parent
        class, which in turn means that it really behaves as a separate
        class rather than something strongly related to NoteEditor.
        This is a cleaner way to create inner classes if they do not need
        access to state from the outer class, keeps the generated class
        small, and allows it to be used easily from other classes.
      

        It extends EditText, which is the View we have chosen to
        customize in this case. When we are finished, the new class will be
        able to substitute for a normal EditText view.
      



Class Initialization
As always, the super is called first. Furthermore,
    this is not a default constructor, but a parameterized one. The
    EditText is created with these parameters when it is inflated from an
    XML layout file, thus, our constructor needs to both take them and pass them
    to the superclass constructor as well.


Overridden Methods
This example overrides only one method, onDraw(), but you might need to
      override others as you create your own custom components.
For this sample, overriding the onDraw() method allows
    us to paint the blue lines on the EditText view canvas (the
    canvas is passed into the overridden onDraw() method). The
    super.onDraw() method is called before the method ends. The
    superclass method should be invoked, and in this case, we do it at the
    end after we have painted the lines we want to include.

Use the Custom Component
We now have our custom component, but how can we use it? In the
    NotePad example, the custom component is used directly from the
    declarative layout, so take a look at note_editor.xml in the
    
      res/layout folder.

<view xmlns:android="http://schemas.android.com/apk/res/android"
    class="com.example.android.notepad.NoteEditor$LinedEditText"
    android:id="@+id/note"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/transparent"
    android:padding="5dp"
    android:scrollbars="vertical"
    android:fadingEdge="vertical"
    android:gravity="top"
    android:textSize="22sp"
    android:capitalize="sentences"
/>



        The custom component is created as a generic view in the XML, and
        the class is specified using the full package. Note also that the
        inner class we defined is referenced using the
        NoteEditor$LinedEditText notation which is a standard way to
        refer to inner classes in the Java programming language.
        If your custom View component is not defined as an inner class, then you can,
        alternatively, declare the View component
        with the XML element name, and exclude the class attribute. For example:

<com.example.android.notepad.LinedEditText
  id="@+id/note"
  ... />

Notice that the LinedEditText class is now a separate class file. When the class
      is nested in the NoteEditor class, this technique will not work.


        The other attributes and parameters in the definition are the ones
        passed into the custom component constructor, and then passed
        through to the EditText constructor, so they are the same
        parameters that you would use for an EditText view. Note that it is
        possible to add your own parameters as well, and we will touch on
        this again below.
      



And that's all there is to it. Admittedly this is a simple case, but
that's the point — creating custom components is only as complicated as you
need it to be.
A more sophisticated component may override even more on... methods and
introduce some of its own helper methods, substantially customizing its properties and
behavior. The only limit is your imagination and what you need the component to
do.


Content and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates.

      
      Last updated January 23, 2019.
    





          
          
            Twitter
          
        Follow @AndroidDev on Twitter
          
          
            YouTube
          
        Check out Android Developers on YouTubeMore Android
                Android
            
                Enterprise
            
                Security
            
                Source
            Support
                Report platform bug
            
                Report documentation bug
            
                Google Play support
            
                Join user studies
            Documentation
                Developer guides
            
                Design guides
            
                API reference
            
                Samples
            
                Android Studio
            
                Android
            
                Chrome
            
                Firebase
            
                Google Cloud Platform
            
                All Products
            
            Bahasa Indonesia
          
            Deutsch
          
            English
          
            español
          
            Español (América Latina)
          
            français
          
            Português Brasileiro
          
            Tiếng Việt
          
            Türkçe
          
            Русский
          
            ภาษาไทย
          
            日本語
          
            简体中文
          
            繁體中文
          
            한국어
          Privacy
         License
         Brand Guidelines
         
        Get Android and Google Play news by email
      
        
        Subscribe
      
