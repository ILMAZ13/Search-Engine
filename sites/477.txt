Add support for Dynamic Delivery  |  Android DevelopersAndroid Developers
          Platform
        
          Android Studio
        
          Google Play
        
          Android Jetpack
        
          Docs
        
          News
        
    
    
    
      Android Studio
    
    
  
          Download
        
          What's new
        
          User guide
        
          Preview
        







          Platform
        



          Android Studio
        




          Download
        



          What's new
        



          User guide
        



          Preview
        






          Google Play
        



          Android Jetpack
        



          Docs
        



          News
        












Meet Android StudioOverviewInstall Android StudioMigrate to Android StudioConfigure the IDEKeyboard shortcutsAccessibility featuresUpdate the IDE and toolsWorkflow basicsManage your projectOverviewCreate a projectAdd Kotlin codeAdd support for Dynamic DeliveryAdd C and C++ codeOverviewConfigure CMakeLink GradleCreate an Android librarySet up continuous integrationWrite your appOverviewAdd code from a templateFind sample codeAdd a module for a new deviceCreate a Java class or typeUse Java 8 language featuresAdd app resourcesBuild a UI with Layout EditorDesign app themesAdd multi-density vector graphicsCreate icons with Image Asset StudioCreate resizable bitmaps (9-Patch)Create WebP imagesLocalize the UIAdd Android app linksConnect to FirebaseImprove your code with lint checksImprove code inspection with annotationsTools attributes referenceBuild and run your appOverviewRun apps on the emulatorOverviewCreate and manage virtual devicesStart the emulator from the command lineSend emulator console commandsSet up emulator networkingConfigure hardware accelerationEmulator feature comparisonTroubleshoot emulatorRun apps on a hardware deviceOverviewInstall OEM USB driversGet the Google USB driverCreate run/debug configurationsBuild your app from the command lineConfigure your buildOverviewSet the application IDAdd build dependenciesOptimize your build speedUse the build cacheConfigure build variantsBuild multiple APKsMerge multiple manifestsInject build variables into the manifestShrink your code and resourcesEnable multidexAnalyze your build with APK AnalyzerGradle tips and recipesDebug your appOverviewConfigure developer optionsWrite and view logsAnalyze a stack traceDebug your layout with Layout InspectorVerify your design with Pixel PerfectView on-device filesTake a screenshotRecord a videoCapture and read bug reportsTest your appOverviewTest from the command lineCreate UI tests with Espresso Test RecorderUI/App Exerciser Monkeymonkeyrunner referenceOverviewMonkeyDeviceMonkeyImageMonkeyRunnerProfile your appOverviewMeasure app performanceProfile and debug pre-built APKsInspect CPU activityOverviewGenerate trace logs by instrumenting your appPerform on-device system tracingView the heap and memory allocationsInspect network activityInspect energy useInspect GPU renderingProfile battery usagePublish your appOverviewPrepare for releaseVersion your appSign your appUpload your appCommand line toolsOverviewaapt2adbapkanalyzerapksigneravdmanagerbmgrbundletoold8dmtracedumpdumpsysetc1tooljobbjetifier-standalonelogcatmksdcardsdkmanagersystracezipalignEnvironment variablesTroubleshootKnown issuesReport a bug









    
    
      Android Developers
    
    
    




    
    
      Android Studio
    
    
    




    
    
      User guide
    
    
    




    Add support for Dynamic Delivery
  


Google Play’s app serving model, called Dynamic Delivery, uses
Android App Bundles to generate and serve optimized APKs
for each user’s device configuration, so users download only the code and
resources they need to run your app. You no longer have to build, sign, and
manage multiple APKs to support different devices, and users get smaller, more
optimized downloads.
Most app projects won’t require much effort to build app bundles that support
serving optimized APKs using Dynamic Delivery. For example, if you already
organize your app’s code and resources
according to established conventions, you can
build signed Android App Bundles
using Android Studio and
upload them to Google Play.
Dynamic Delivery then becomes an automatic benefit.
The benefits of Dynamic Delivery also allow you to modularize app features that
aren't required at install time by adding
dynamic feature modules
to your app project and including them in your app bundle. Through Dynamic
Delivery, your users can then download and install your app’s dynamic features
on-demand. However, creating on-demand modules requires more effort and
possible refactoring of your app. So, consider carefully which of your app’s
features would benefit the most from being available to users on-demand.
This page helps you configure your app to support Dynamic Delivery and add a
dynamic feature module to your app project. Before you begin, make sure you're
using Android Studio 3.2 or higher and Android Gradle Plugin
3.2.0 or higher.
The base module
Most app projects won’t require much effort to support Dynamic Delivery.
That’s because the module that includes code and resources for your app’s base
APK is the standard app module, which you get by default when you
create a new app project in Android Studio.
That is, the module that applies the app plugin below to its build.gradle file
provides the code and resources for the base functionality of your app.
// The standard application plugin creates your app's base module.
apply plugin: 'com.android.application'

If you are concerned with reducing your app’s initial download size, it’s
important to keep in mind that all code and resources included in this module
are included in your app’s base APK.
In addition to providing the core functionality for your app, the base module
also provides many of the build configurations and manifest entries that
affect your entire app project. For example, signing for your app bundle is
determined by information you provide for the base module, and versioning of
all your app’s APKs are specified on the versionCode attribute in your base
module’s manifest. Other important aspects of the base module are described
below.
The base module manifest
The manifest for your app’s base module is similar to that of any other app
module. Keep in mind, when Google Play generates your app’s base APK, it merges
manifests for all modules into that  of the base APK. So, if you are considering
adding dynamic feature modules to your app project,
there are some aspects to the base APK's manifest that you should keep in mind:

Because the base APK is always installed first, it should provide the main
entry point for your app. That is, it should declare an activity with the
following intent filter:
<intent-filter>
     <action android:name="android.intent.action.MAIN" />
     <category android:name="android.intent.category.LAUNCHER" />
</intent-filter>

When downloading dynamic feature modules on-demand, devices running Android
6.0 (API level 23) and lower require the app to restart before completing
installation of the new modules. However, if you want to be able to access
the downloaded module’s code and resources immediately after it’s downloaded,
you should include support for the SplitCompat library in your manifest. To
learn more, read
Access code and resources from downloaded modules.
Similarly, on devices running Android 6.0 (API level 23) and lower, apps need
to restart before the platform can apply new manifest entries. So, if you
require certain permissions or services as soon as a dynamic feature module
is downloaded, consider including them in the manifest of your base module.

The base module build configuration
For most existing app projects, you don’t need to change anything in your base
module’s build configuration. However, if you are considering adding dynamic
feature modules to your app project, there are some aspects to the base
module’s build configuration that you should keep in mind:

App signing: You don’t need to include signing information in the build
configuration file unless you want to
build your app bundle from the command line.
However, if you do include signing information, you should include it in
only the base module’s build configuration file. For more information, see
Configure Gradle to sign your app.
Code shrinking: If you want to
enable code shrinking for your
entire app project (including its dynamic feature modules), you must do
so from the base module’s build.gradle file. That is, you can
include custom ProGuard rules in a dynamic
feature module, but the minifyEnabled property in dynamic feature
module build configurations is ignored.
The splits block is ignored: When building an app bundle, Gradle
ignores properties in the android.splits block. If you want to control
which types of configuration APKs your app bundle supports, instead use
android.bundle to
disable types of configuration APKs.
App versioning: The base module determines the version code and version
name for your entire app project. For more information, go to the section
about how to Manage app updates.

Disable types of configuration APKs
By default, when you build an app bundle, it supports generating configuration
APKs for each set of language resources, screen density resources, and ABI
libraries. Using the android.bundle block in your base module’s
build.gradle file, as shown below, you can disable support for one or more
types of configuration APKs:
android {
    // When building Android App Bundles, the splits block is ignored.
    splits {...}

    // Instead, use the bundle block to control which types of configuration APKs
    // you want your app bundle to support.
    bundle {
        language {
            // Specifies that the app bundle should not support
            // configuration APKs for language resources. These
            // resources are instead packaged with each base and
            // dynamic feature APK.
            enableSplit = false
        }
        density {
            // This property is set to true by default.
            enableSplit = true
        }
        abi {
            // This property is set to true by default.
            enableSplit = true
        }
    }
}

Manage app updates
With Android App Bundles and Dynamic Delivery, you no longer have to manage
version codes for multiple APKs that you upload to Google Play. Instead, you
manage only one version code in the base module of your app, as shown below:
// In your base module build.gradle file
android {
    defaultConfig {
        …
        // You specify your app’s version code only in the base module.
        versionCode 5
        versionName "1.0"
    }
}

After you upload your app bundle, Google Play uses the version code in your
base module to assign the same version code to all the APKs it generates from
that bundle. That is, when a device downloads and installs your app, all split
APKs for that app share the same version code.
When you want to update your app with new code or resources, you must update
the version code in your app’s base module, and build a new, full app bundle.
When you upload that app bundle to Google Play, it generates a new set of APKs
based on the version code the base module specifies. Subsequently, when users
update your app, Google Play serves them updated versions of all APKs
currently installed on the device. That is, all installed APKs are updated to
the new version code.
Note: Because you no longer need to manage version codes for all of your app’s
APKs,  you no longer need to include logic to
dynamically modify version codes
based on device configuration.
Download additional configuration APKs
One exception to the update flow described above is when an installed app
requires additional configuration APKs. Consider a user who changes their
default system language after already downloading your app. If your app
supports that language, the device requests and downloads additional
configuration APKs for those language resources from Google Play. However, this
type of update to your app does not change its version code, so the device
downloads and installs only the configuration APKs that it requires.
Dynamic feature modules
Dynamic feature modules allow you to separate certain features and resources
from the base module of your app and include them in your app bundle. Through
Dynamic Delivery, users can later download and install those components on
demand after they’ve already installed the base APK of your app.
For example, consider a text messaging app that includes functionality for
capturing and sending picture messages, but only a small percentage of users
send picture messages. It may make sense to include picture messaging as a
downloadable dynamic feature module. That way, the initial app download is
smaller for all users and only those users who send picture messages need to
download that additional component.
Keep in mind, this type of modularization requires more effort and possibly
refactoring your app’s existing code, so consider carefully which of your
app’s features would benefit the most from being available to users on-demand.
Android App Bundles provide some additional options that help you transition
your app towards supporting fully on-demand features. These options are
described later in this section.
Note: If your app includes dynamic feature modules, you can upload and
test your app through the Play Console's internal test track.
However, to publish your app to production, you must apply for the Dynamic
Features Beta Program. To learn more, go to the Play Console help topic about
the
Beta program for publishing apps with dynamic feature modules.
In general, dynamic feature modules are organized just like regular app
modules. They provide their own code, resources, and assets in the directories
you would expect. However, there are some additional attributes in the
manifest file and properties in the build configuration that allow dynamic
feature modules to enable downloading them on-demand.
This section explains those differences and how to create dynamic feature
modules using Android Studio.
Create a dynamic feature module
The easiest way to create a new dynamic feature module is by using
Android Studio 3.2 or higher.
Because dynamic feature modules have an
inherent dependency on the base app module, you can add them only to existing
app projects.
To add a dynamic feature module to your app project using Android Studio,
proceed as follows:

If you haven’t already done so, open your app project in the IDE.
Select File > New > New Module from the menu bar.
In the Create New Module dialog, select
Dynamic Feature Module and click Next.
In the Configure your new module section, complete the
following:

Select the Base application module for your app project from
the dropdown menu.
Specify a Module name. The IDE uses this name to identify the
module as a Gradle subproject in your
Gradle settings file. When you
build your app bundle, Gradle uses the last element of the subproject
name to inject the <manifest split> attribute in the
dynamic feature module’s manifest.
Specify the module’s package name. By default, Android Studio
suggests a package name that combines the root package name of the
base module and the module name you specified in the previous step.
Select the Minimum API level you want the module to support.
This value should match that of the base module.

Click Next.
In the Configure On-Demand Options section, proceed as follows:

Specify the Module title using up to 50 characters. The platform
uses this title to identify the module to users when, for example,
confirming whether the user wants to download the module. For this
reason, your app’s base module must include the module title as a
string resource, which you
can translate. When creating the module using Android Studio, the IDE
adds the string resource to the base module for you and injects the
following entry in the dynamic feature module’s manifest:
<dist:module
    ...
    dist:title="@string/title_dynamic_feature">
</dist:module>
Note: If you enable resource shrinking, such as for your release builds,
the shrinker may remove the module title string resource if code in your
base module does not reference it. To make sure the string resource
remains in the build output, include the resource in a
custom resource keep file.
Check the box next to Enable on-demand if you want the module
to be available for on-demand downloads. If you do not enable
this option, the dynamic feature is available when a user first
downloads and installs your app. Android Studio injects the
following in the module’s manifest to reflect your choice.
<dist:module
    ...
    dist:onDemand="true">
</dist:module>

Check the box next to Fusing if you want this module to be available
to devices running Android 4.4 (API level 20) and lower and include it in
multi-APKs. This option is available only
if you checked the box next to Enable on-demand in the previous
step. That means you can enable on-demand behavior for this module
and disable fusing to omit it from devices that don’t support
downloading and installing split APKs. Android Studio injects the
following in the module’s manifest to reflect your choice.
<dist:module
    ...
    <dist:fusing dist:include="true" />
</dist:module>


Click Finish.

After Android Studio finishes creating your module, inspect its contents
yourself from the Project pane (select View > Tool Windows > Project
from the menu bar). You should quickly notice that the default code,
resources, and organization are similar to that of the standard app module.
Dynamic feature module build configuration
When you create a new dynamic feature module using Android Studio, the IDE
applies the following Gradle plugin to the module’s build.gradle file.
// The following applies the dynamic-feature plugin to your dynamic feature module.
// The plugin includes the Gradle tasks and properties required to configure and build
// an app bundle that includes your dynamic feature module.

apply plugin: 'com.android.dynamic-feature'

Many of the properties available to
the standard application plugin
are also available to your dynamic feature module. The following sections
describe the properties you should and shouldn’t include in your dynamic
feature module’s build configuration.
What not to include in the dynamic feature module build configuration
Because each dynamic feature module depends on the base module, it also
inherits certain configurations. So, you should omit the following in the
dynamic feature module’s build.gradle file:

Signing configurations: App bundles are signed using signing
configurations that you specify in the base module.
The minifyEnabled property: You can
enable code shrinking
for your entire app project from only the base module’s build
configuration. So, you should omit this property from dynamic
feature modules. You can, however,
specify additional ProGuard rules
for each dynamic feature module.
versionCode and versionName: When building your app bundle,
Gradle uses app version information that the base module provides.
You should omit these properties from your dynamic module’s
build.gradle file.

Establish a relationship to the base module
When Android Studio creates your dynamic feature module, it makes it visible
to the base module by adding the android.dynamicFeatures property to the
base module’s build.gradle file, as shown below:
// In the base module’s build.gradle file.
android {
    ...
    // Specifies dynamic feature modules that have a dependency on
    // this base module.
    dynamicFeatures = [":dynamic_feature", ":dynamic_feature2"]
}

Additionally, Android Studio includes the base module as a dependency of the
dynamic feature module, as shown below:
// In the dynamic feature module’s build.gradle file:
...
dependencies {
    ...
    // Declares a dependency on the base module, ':app'.
    implementation project(':app')
}

Specify additional ProGuard rules
Although only the base module’s build configuration may enable code shrinking
for your app project, you can provide custom ProGuard rules with each dynamic
feature module using the
proguardFiles
property, as shown below.
android.buildTypes {
     release {
         // You must use the following property to specify additional ProGuard
         // rules for dynamic feature modules.
         proguardFiles 'proguard-rules-dynamic-features.pro'
     }
}

Note that these ProGuard rules are merged with those from other modules
(including the base module) at build time. So, while each dynamic feature
module may specify a new set of rules, those rules apply to all modules in the
app project.
Dynamic feature module manifest
When creating a new dynamic feature module using Android Studio, the IDE
includes most of the manifest attributes that the module requires to behave
like a dynamic feature. Additionally, some attributes are injected by the
build system at compile time, so you needn’t specify or modify them yourself.
The following table describes the manifest attributes that are important to
dynamic feature modules.



Attribute Description


<manifest...
This is your typical
      
<manifest> block.


xmlns:dist="http://schemas.android.com/apk/distribution"
Specifies a new dist: XML namespace that’s
    described further below.


split="split_name"

        When Android Studio builds your app bundle, it includes this
        attribute for you. So, you should not include or modify
        this attribute yourself.
      
        Defines the name of the module, which your app specifies
        when requesting an on-demand module using the Play Core Library.
      
How Gradle determines the value for this attribute:

        By default, when you create a dynamic feature module using
        Android Studio, The IDE uses what you specify as its
        Module name to identify the module as a Gradle subproject
        in your 
        Gradle settings file.
      

        When you build your app bundle, Gradle uses the last element of
        the subproject path to inject this manifest attribute in the module’s
        manifest. For example, if you create a new dynamic feature module in
        the MyAppProject/features/ directory and specified
        "dynamic_feature1" as its Module name, the IDE adds
        ':features:dynamic_feature1' as a subproject in your
        settings.gradle file. When building your app bundle,
        Gradle then injects
        <manifest split="dynamic_feature1">
        in the module’s manifest.



android:isFeatureSplit="true | false">

        When Android Studio builds your app bundle, it includes
        this attribute for you. So, you should not include
        or modify this attribute manually.
      
        Specifies that this module is a dynamic feature module.
        Manifests in the base module and configuration APKs either
        omit this attribute or set it to false.
      



<dist:module
This new XML element defines attributes that determine how the
    module is packaged and distributed as APKs.


dist:onDemand="true | false"

      Specifies whether the module should be available as an on-demand
      download. That is, if this attribute is set to true,
      the module is not available at install time, but your app may
      request to download it later.
      If this attribute is set to false, the module is
      included when the user first downloads and installs your app.
To learn more about on-demand downloads, read about
        
        Download modules with the Play Core Library.
      



dist:title="@string/feature_name"

      Specifies a user-facing title for the module. For example,
      the device may display this title when it requests download
      confirmation.
      You need to include the string resource for this title
        in the base module’s module_root/src/source_set/res/values/strings.xml
        file.
      



<dist:fusing dist:include="true | false" />
      </dist:module>

    Specifies whether to include the module in multi-APKs that
    target devices running Android 4.4 (API level 20) and lower.
    Additionally, when you 
    use bundletool to generate APKs from an app bundle,
    only dynamic feature modules that set this property to true
    are included in the universal APK—which is a monolithic APK that includes
      code and resources for all device configurations your app supports.
    



<application
      
android:hasCode="true | false">
      ...
      </application>
    
    If the dynamic feature module generates no DEX files—that is, it contains
    no code that is later compiled into the DEX file format—you must do the
    following (otherwise, you may get runtime errors):
    
Set android:hasCode to "false" in the dynamic
        feature module's manifest.
Add the following to your base module's manifest:

<application
  android:hasCode="true"
  tools:replace="android:hasCode">
  ...
</application>






Note: Dynamic feature modules should not specify activities in their manifest with
android:exported set to
true. That's because there's no guarantee that the device
has downloaded the dynamic feature module when another app tries to launch the
activity. Additionally, your app should confirm that a dynamic feature is
downloaded before trying to access its code and resources. To learn more, read
Manage installed modules.
Deploy your app
While you’re developing your app with support for Dynamic Delivery, you can
deploy your app to a connected device like you normally would by selecting
Run > Run from the menu bar (or by clicking Run  in
the toolbar).
If your app project includes one or more dynamic feature modules, you can
choose which dynamic features to include when deploying your app by modifying
your existing run/debug configuration as
follows:

Select Run > Edit Configurations from the menu bar.
From the left panel of the Run/Debug Configurations dialog, select
your desired Android App configuration.
Under Dynamic features to deploy in the General tab, check the
box next to each dynamic feature module you want to include when
deploying your app.
Click OK.

By default, Android Studio doesn’t use app bundles to deploy your app—it builds
and pushes APKs to your device that are optimized for deployment speed,
rather than APK size. To configure Android Studio to instead build and deploy
APKs from an app bundle,
modify your run/debug configuration
and select the option to deploy APK from app bundle.


Content and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates.

      
      Last updated February 12, 2019.
    





          
          
            Twitter
          
        Follow @AndroidDev on Twitter
          
          
            YouTube
          
        Check out Android Developers on YouTubeMore Android
                Android
            
                Enterprise
            
                Security
            
                Source
            Support
                Report platform bug
            
                Report documentation bug
            
                Google Play support
            
                Join user studies
            Documentation
                Developer guides
            
                Design guides
            
                API reference
            
                Samples
            
                Android Studio
            
                Android
            
                Chrome
            
                Firebase
            
                Google Cloud Platform
            
                All Products
            
            Bahasa Indonesia
          
            Deutsch
          
            English
          
            español
          
            Español (América Latina)
          
            français
          
            Português Brasileiro
          
            Tiếng Việt
          
            Türkçe
          
            Русский
          
            ภาษาไทย
          
            日本語
          
            简体中文
          
            繁體中文
          
            한국어
          Privacy
         License
         Brand Guidelines
         
        Get Android and Google Play news by email
      
        
        Subscribe
      
