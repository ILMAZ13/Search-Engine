Creating a Search Interface  |  Android DevelopersAndroid Developers
          Platform
        
          Android Studio
        
          Google Play
        
          Android Jetpack
        
          Docs
        
          News
        
    
    
    
      Documentation
    
    
  
          Overview
        
          Guides
        
          Reference
        
          Samples
        
          Design & Quality
        







          Platform
        



          Android Studio
        



          Google Play
        



          Android Jetpack
        



          Docs
        




          Overview
        



          Guides
        



          Reference
        



          Samples
        



          Design & Quality
        






          News
        












App BasicsIntroductionBuild your first appOverviewCreate an Android projectRun your appBuild a simple user interfaceStart another activityApp fundamentalsApp resourcesOverviewHandle configuration changesLocalizationLocalize your appTest your app with pseudolocalesUnicode and internationalization supportLanguage and locale resolutionComplex XML resourcesResource typesOverviewAnimationColor state listDrawableLayoutMenuStringStyleFontMore typesApp manifest fileOverview<action><activity><activity-alias><application><category><compatible-screens><data><grant-uri-permission><instrumentation><intent-filter><manifest><meta-data><path-permission><permission><permission-group><permission-tree><provider><receiver><service><supports-gl-texture><supports-screens><uses-configuration><uses-feature><uses-library><uses-permission><uses-permission-sdk-23><uses-sdk>App permissionsOverviewRequest app permissionsApp permissions best practicesDefine custom permissionsDevicesDevice compatibilityOverviewScreen compatibility overviewSupport different screen sizesSupport different pixel densitiesSupport display cutoutsDeclare restricted screen supportMultiple APK supportOverviewCreate multiple APKs for different API levelsCreate multiple APKs for different screen sizesCreate multiple APKs for different GL texturesCreate multiple APKs with several dimensionsSupport different languages and culturesSupport different platform versionsFilters on Google PlayWearOverviewAdding wearable features to notificationsOverviewCreating a notificationNotification stylesBridging mode for notificationsMaintaining compatibilityCreating wearable appsOverviewCreating and running a wearable appStandalone appsCreating custom layoutsKeeping your app visibleAuthentication in WearAdding voice capabilitiesPackaging and distributing Wear appsDebugging a Wear appCapturing Wear UI screenshotsCreating Wear apps for ChinaCreating custom UIsOverviewDefining layoutsCreating listsShowing confirmationsExiting full-screen activitiesUsing the Wear UI libraryWear navigation and actionsMulti-function buttonsRotary inputCreating input method editorsUsing wrist gesturesSending and syncing dataOverviewNetwork access and syncingAccessing the wearable data layerSyncing data itemsTransferring assetsSending and receiving messagesHandling data layer eventsMigrating Wear apps to GoogleApiCreating data providersOverviewExpose data to complicationsCreating watch facesOverviewDesigning watch facesBuilding a watch face serviceDrawing watch facesWatch face complicationsExposing data to complicationsAdding complications to a watch faceCreating interactive watch facesProviding configuration activitiesAddressing common issuesOptimizing watch facesDetecting locationRequesting PermissionsUsing the SpeakerAndroid TVOverviewBuilding TV AppsOverviewGetting started with TV appsHandling TV hardwareManaging TV controllersBuilding TV layoutsCreating TV navigationBuilding TV playback appsOverviewCreating a catalog browserProviding a card viewBuilding a details viewUsing Leanback transport controlsDisplaying a now playing cardAdding a guided stepIntroducing first-time users to your appEnabling background playbackHelping users find content on TVOverviewRecommending TV contentOverviewChannels on the home screenVideo program attributesAudio program attributesGame program attributesWatch next attributesPreviewing videosRecommendations in Android N and earlierMaking TV apps searchableSearching within TV AppsBuilding TV gamesBuilding TV channelsOverviewDeveloping a TV input serviceWorking with channel dataManaging user interactionSupporting time-shiftingSupporting content recordingTV Apps checklistAndroid AutoOverviewGetting Started with AutoPlaying Audio for AutoMessaging for AutoTesting for AutoAndroid ThingsOverviewPlatform differencesGoogle servicesSupported hardwareDeveloper kitsGet startedNXP i.MX7DRaspberry Pi 3Advanced setupOverviewManually flash an imageRecover a deviceConnecting to Wi-Fi with adbBuild appsCreate a Things appOverviewCreate a projectConnect the hardwareInteract with peripheralsIntegrate peripheral driversCommunicate with wireless devicesBluetoothLoWPANConfigure devicesSettingsUpdatesInteract with peripheralsOverviewGPIOPWMI2CSPIUARTNative PIOCLI toolIntegrate native codeBuild user-space driversOverviewLocationInputSensorsLoWPANSamplesManage devicesOverviewCreate a productConfigure a productCreate a buildOverviewManage appsPush an updateOverviewAutomatic updatesMonitor analyticsTermsConsole Terms of ServiceSDK License AgreementAndroid Things ConsoleChrome OS devicesOverviewBuilding apps for Chrome OSPreparing your development environmentOptimizing Apps for Chrome OSResolving Issues with Screen SizeApp Manifest Compatibility for ChromebooksLoading Apps on ChromebooksChrome OS Device Support for AppsApp Rendering Differences on ChromebooksWindow managementInput compatibility for ChromebooksAndroid Studio on Chrome OSChrome OS devices on EmulatorTest Cases for Android Apps on Chrome OSCore topicsActivitiesIntroduction to activitiesThe activity lifecycleActivity state changesTest your activitiesTasks and back stackProcesses and app lifecycleParcelables and bundlesFragmentsOverviewCreate a fragmentTest your fragmentsBuild a flexible UICommunicate with other fragmentsInteract with other appsOverviewSending the user to another appGetting a result from an activityAllowing other apps to start your activityHandling app linksOverviewEnabling links to app contentVerify app linksCreate app links for instant appsLoadersRecents screenMulti-window supportApp shortcutsOverviewCreate shortcutsManage shortcutsBest practices for shortcutsApp widgetsOverviewBuild an app widgetBuild an app widget hostArchitecture ComponentsOverviewAdding Components to your ProjectData Binding LibraryOverviewGet startedLayouts and binding expressionsWork with observable data objectsGenerated binding classesBinding adaptersBind layout views to Architecture ComponentsTwo-way data bindingHandling LifecyclesLiveDataNavigationOverviewImplement NavigationUpdate UI components with NavigationUINested graphsPass data between destinationsAdd support for new destinationImplement conditional navigationCreate a deep link for a destinationGlobal actionsMigrate to the Navigation ComponentPaging LibraryOverviewUI Components and ConsiderationsData Components and ConsiderationsRoom Persistence LibraryViewModelWorkManagerOverviewBasicsAdvancedMigrating from Firebase JobDispatcherSaving StatesRelease notesIntents and intent filtersOverviewCommon intentsUser interface & navigationOverviewLayoutsOverviewBuild a responsive UI with ConstraintLayoutCreate a list with RecyclerViewCreate a card-based layoutImplementing adaptive UI flowsImproving layout performanceOverviewOptimizing layout hierarchiesRe-using layouts with <include/>Delayed loading of viewsMaking ListView scrolling smoothLinear layoutAdapter viewRelative layoutCustom view componentsOverviewCreating a custom view classImplementing custom drawingMaking the view interactiveOptimizing the viewLook and feelMaterial designStyles and themesAdaptive iconsAdd a floating action buttonCreate shadows and clip viewsTextAutosizing TextViewsDownloadable fontsFonts in XMLEmoji compatibilityMagnifier widgetSpansButtonsCheckboxesRadio buttonsToggle buttonsSpinnersPickersTooltipsNotificationsOverviewCreate a notificationCreate an expandable notificationStart an activity from a notificationCreate a group of notificationsCreate and manage notification channelsModify a notification BadgeCreate a custom notificationAdd the app barOverviewSet up the app barAdd and handle actionsAdd an up actionUse action views and action providersControl the system UI visibilityOverviewDim the system barsHide the status barHide the navigation barEnable fullscreen modeRespond to UI visibility changesDesigning effective navigationOverviewPlanning screens and their relationshipsPlanning for multiple touchscreen sizesProviding descendant and lateral navigationDesigning back and up navigationPutting it all together: wireframing the example appImplementing effective navigationOverviewCreating swipe views with tabsCreating a navigation drawerProviding up navigationProviding proper back navigationImplementing descendant navigationSlide between fragments using ViewPagerSupporting swipe-to-refreshOverviewAdding swipe-to-refresh to your appResponding to a refresh gestureToasts overviewPop-up messages overviewOverviewBuild and display a pop-up messageAdd an action to a messageDialogsMenusSettingsOverviewOrganize your settingsCustomize your settingsUse saved valuesBuild a hierarchy in codeHandle other form factorsPreference components and attributesSearchOverviewCreating a search interfaceAdding recent query suggestionsAdding custom suggestionsSearchable configurationAdding search functionalityOverviewSetting up the search interfaceStoring and searching for dataRemaining backward compatibleCopy and pasteDrag and dropCreating backward-compatible UIsOverviewAbstracting the new APIsProxying to the new APIsCreating an implementation with older APIsUsing the version-aware componentAnimations & transitionsOverviewAnimations overviewProperty animation overviewAnimate drawable graphicsReveal or hide a view using animationMove a view using animationMove a view using a fling animationEnlarge a view using a zoom animationAnimate movement using spring physicsAuto animate layout updatesAnimate layout changes using a transitionCreate a custom transition animationStart an activity using an animationImages & graphicsOverviewDrawables overviewVector drawables overviewHandling bitmapsSelecting colors with the palette APIReducing image download sizesHardware accelerationOpenGL ESDisplaying graphics with OpenGL ESOverviewBuilding an OpenGL ES environmentDefining shapesDrawing shapesApplying projection and camera viewsAdding motionResponding to touch eventsRenderingOverviewReducing overdrawPerformance and view hierarchiesAnalyzing with profile GPU renderingEnhancing graphics with wide color contentAudio & videoAudio & video overviewSupported media formatsMedia app architectureMedia app architecture overviewUsing a media sessionBuilding an audio appAudio app overviewBuilding a media browser serviceBuilding a media browser clientMedia session callbacksBuilding a video appVideo app overviewBuilding a video player activityMedia session callbacksResponding to media buttonsHandling changes in audio outputManaging audio focusThe Google Assistant and media appsRouting between devicesRouting overviewMediaRouter overviewMediaRouteProvider overviewControl amplitude with VolumeShaperMediaPlayer overviewMediaRecorder overviewExoPlayerBackground tasksOverviewGuide to background processingSending operations to multiple threadsOverviewSpecify the code to run on a threadCreate a manager for multiple threadsRun code on a thread pool threadCommunicate with the UI threadSchedule jobs intelligentlyServicesOverviewCreate a background serviceSend work requests to the background serviceReport work statusBound servicesAIDL overviewBackground optimizationsBroadcasts overviewImplicit Broadcast ExceptionsManage device awake stateOverviewKeep the device awakeSchedule repeating alarmsApp data & filesOverviewStorage overviewSave files on device storageSave key-value dataSave data in a local databaseOverviewDefine data using entitiesCreate views into a databaseAccess data using DAOsMigrate your databaseTest your databaseReference complex dataSharing simple dataOverviewSending simple data to other appsReceiving simple data from other appsAdding an easy share actionSharing filesOverviewSetting up file sharingSharing a fileRequesting a shared fileRetrieving file informationSharing files with NFCOverviewSending files to another deviceReceiving files from another devicePrinting filesOverviewPrinting photosPrinting HTML documentsPrinting custom documentsContent providersOverviewContent provider basicsCreating a content providerOpen files using storage access frameworkCreate a custom document providerApp install locationUser data & identityOverviewAdd sign-in workflowAutofill frameworkOverviewOptimize your app for autofillBuild autofill servicesCalendar provider overviewContacts providerOverviewRetrieving a list of contactsRetrieving details for a contactModifying contacts using intentsDisplaying the quick contact badgeAccount transferData backupOverviewBack up user dataBack up key-value pairsOverviewRegisterTest backup and restoreBest practices for unique identifiersRemember and authenticate usersOverviewRemember your userAuthenticate to OAuth2 servicesCreate a custom account typeUser locationOverviewOptimize location for batteryGet the last known locationChange location settingsReceive location updatesDisplay a location addressCreate and monitor geofencesDetect when users start an activityMigrate to location and context APIsAdd mapsTouch & inputOverviewInput eventsUsing touch gesturesOverviewDetect common gesturesTrack touch and pointer movementsAnimate a scroll gestureHandle multi-touch gesturesDrag and scaleManage touch events in a ViewGroupHandling keyboard inputOverviewSpecifying the input method typeHandling input method visibilitySupporting keyboard navigationHandling keyboard actionsSupporting game controllersOverviewHandling controller actionsSupporting controllers across Android versionsSupporting multiple game controllersInput method editorsCreating an input methodImage keyboardSpelling checkerCameraOverviewTaking photosRecording videosControlling the cameraCamera APISensorsOverviewSensors overviewMotion sensorsPosition sensorsEnvironment sensorsRaw GNSS measurementsConnectivityOverviewPerforming network operationsOverviewConnect to the networkManage network usageOptimize network data usageParse XML dataTransmit network data using VolleyOverviewSend a simple requestSet up RequestQueueMake a standard requestImplement a custom requestPerform network operations using CronetOverviewSend a simple requestCronet request lifecycleReferenceorg.chromium.netOverviewCallbackExceptionCronetEngineOverviewCronetEngine.BuilderOverviewLibraryLoaderCronetExceptionInlineExecutionProhibitedExceptionNetworkExceptionQuicExceptionUploadDataProviderUploadDataProvidersUploadDataSinkUrlRequestOverviewBuilderCallbackStatusStatusListenerUrlResponseInfoOverviewHeaderBlockTransferring data without draining the batteryOverviewOptimize downloads for efficient network accessMinimize the effect of regular updatesAvoid redundant downloadsModify patterns based on the connectivity typeReduce network battery drainOverviewCollecting network traffic dataAnalyzing data trafficOptimizing user-initiated network useOptimizing app-initiated network useOptimizing server-initiated network useOptimizing general network useTransfer data using Sync AdaptersOverviewCreate a Stub AuthenticatorCreate a Stub Content ProviderCreate a Sync AdapterRun a Sync AdapterBluetoothOverviewBluetooth low energy overviewNFCOverviewNFC basicsAdvanced NFCHost-based card emulation overviewTelecomOverviewBuild a calling appWi-FiWi-Fi scanning overviewWi-Fi peer-to-peer overviewWi-Fi aware overviewWi-Fi location with RTTCompanion device pairing overviewUSBOverviewAccessory overviewHost overviewVPNSession initiation protocol overviewDiscover and connectOverviewUse network service discoveryCreate P2P connections with Wi-FiUse Wi-Fi P2P for service discoveryRenderscriptOverviewAdvanced RenderScriptRuntime API referenceOverviewNumerical typesObject typesConversion functionsMathematical constants and functionsVector math functionsMatrix functionsQuaternion functionsAtomic update functionsTime functions and typesAllocation data access functionsObject characteristics functionsKernel invocation functions and typesInput/output functionsDebugging functionsGraphics functions and typesIndexWeb-based contentOverviewBuilding web apps in WebViewManaging WebView objectsMigrating to WebView in Android 4.4Supporting different screens in web appsDebugging web appsBest practices for web appsAndroid App BundlesOverviewDownload modules with the Play Core LibraryGoogle Play InstantOverview of Google Play InstantGet started with instant appsCreate an instant-enabled app bundleUX best practices for appsGet started with instant gamesOverviewUnity pluginTechnical requirements checklist for gamesUX best practices for gamesReduce the size of your instant app or gameAdd ads to your instant app or gameProvide multiple entry pointsIntegrate with FirebaseAdd Google Analytics for Firebase to your instant appUse Firebase Dynamic Links with instant appsGoogle Play Instant policyResourcesReferenceCode samplesSDK release notesSupportFAQsKnown issuesStackOverflowApp ActionsSlicesOverviewGetting StartedSlice templatesBest practicesTestingOverviewFundamentals of testingSet up projectBuilding effective unit testsOverviewBuilding local unit testsBuilding instrumented unit testsAutomating UI testsOverviewTesting UI for a single appTesting UI for multiple appsTesting app component integrationsOverviewTesting your serviceTesting your content providerTesting UI performanceEspressoOverviewSetup instructionsBasicsRecipesMultiprocessAccessibility checkingListsIntentsWebIdling resourceCheat sheetUI AutomatorJUnit4 RulesAndroidJUnitRunnerSamplesRelease notesPerformanceOverviewAndroid VitalsOverviewStuck Partial Wake LocksExcessive WakeupsExcessive Background Wi-Fi ScansExcessive Background Network UsageANRsCrashesSlow RenderingFrozen FramesPermission DenialsApp Startup TimeApp Standby BucketsProcesses and Threads OverviewBetter Performance through ThreadingOptimizing for Battery LifeOverviewOptimizing for Doze and App StandbyMonitoring the Battery Level and Charging StateDetermining and Monitoring the Docking State and TypeDetermining and Monitoring the Connectivity StatusPower Management RestrictionsAnalyzing Power Use with Battery HistorianTesting power-related issuesReducing APK SizeManage Your App's MemoryOverview of Memory ManagemementDesigning for SeamlessnessKeeping Your App ResponsivePerformance TipsSMP Primer for AndroidVerifying App Behavior on the Android Runtime (ART)AccessibilityOverviewMaking apps more accessibleUsing node tree debuggingBuilding accessibility servicesBuild accessible custom viewsBuild accessibility serviceTest your app's accessibilitySecurityApp security best practicesSecurity tipsSecurity with HTTPS and SSLNetwork security configurationUpdating your security provider to protect against SSL exploitsProtecting against security threats with SafetyNetOverviewSafetyNet Attestation APISafetyNet Safe Browsing APISafetyNet reCAPTCHA APISafetyNet Verify Apps APICryptographyAndroid Keystore SystemVerifying hardware-backed key pairs with key attestationAndroid Protected ConfirmationSupporting Direct BootUsing scoped directory accessApp security improvement programBuild for BillionsOverviewConnectivityDevice capabilityData costBattery consumptionUI and contentBuild for EnterpriseOverviewDeveloper guideWork profilesSet up managed configurationsWork contactsDevice management policiesDevice managementOverviewBuild a device policy controllerWork profiles on fully managed devicesDedicated devicesOverviewLock task modeMultiple usersCookbookDevice controlNetworking and telephonySecuritySystem updatesNetwork activity loggingAndroid versionsOverviewAndroid 9Android 8.0Android 7.0Device administrationGoogle PlayGoogle Play BillingOverviewUse the Google Play Billing LibraryOverviewAdd one-time product-specific featuresAdd subscription-specific featuresPlay Billing Library referencePlay Billing Library release notesUse In-app Billing with AIDLOverviewIn-app Billing ReferenceAdd Real-time Developer NotificationsBest PracticesTest Google Play BillingMaking Your App Content Searchable by GoogleOptimizing Contextual Content for the AssistantGoogle Play Developer APIAPK Expansion FilesApplication LicensingOverviewLicensing OverviewSetting Up for LicensingAdding Licensing to Your AppLicensing ReferenceGoogle Play Install ReferrerOverviewPlay Install Referrer LibraryOverviewReferenceReleases NotesPlay Install Referrer API









    
    
      Android Developers
    
    
    




    
    
      Docs
    
    
    




    
    
      Guides
    
    
    




    Creating a Search Interface
  


When you're ready to add search functionality to your application, Android helps you implement
the user interface with either a search dialog that appears at the top of the activity window or a
search widget that you can insert in your layout. Both the search dialog and the widget can deliver
the user's search query to a specific activity in your application. This way, the user can initiate
a search from any activity where the search dialog or widget is available, and the system starts the
appropriate activity to perform the search and present results.
Other features available for the search dialog and widget include:

Voice search
Search suggestions based on recent queries
Search suggestions that match actual results in your application data

This guide shows you how to set up your application to provide a search interface
that's assisted by the Android system to deliver search queries, using either the
search dialog or the search widget.
Related resources:

Material Design icons

The Basics


Figure 1. Screenshot of an application's search dialog.

Before you begin, you should decide whether you'll implement your search interface using the
search dialog or the search widget. Both provide the same search features, but in slightly different
ways:

The search dialog is a UI component that's controlled by the Android system.
When activated by the user, the search dialog appears at the top of the activity, as shown in figure
1.
    The Android system controls all events in the search dialog. When the user
submits a query, the system delivers the query to the activity that you specify to
handle searches. The dialog can also provide search suggestions while the user types.
The search widget is an instance of SearchView that
you can place anywhere in your layout. By default, the search widget behaves like a standard EditText widget and doesn't do anything, but you can configure it so that the
Android system handles all input events, delivers queries to the appropriate activity, and provides
search suggestions (just like the search dialog).

Note: If you want, you can handle all user input into the
search widget yourself, using various callback methods and listeners. This document, however,
focuses on how to integrate the search widget with the system for an assisted search
implementation. If you want to handle all user input yourself, read the reference documentation for
SearchView and its nested interfaces. 

When the user executes a search from the search dialog or a search widget, the system creates an
Intent and stores the user query in it. The system then starts the activity
that you've declared to handle searches (the "searchable activity") and delivers it the intent. To
set up your application for this kind of assisted search, you need the following:

A searchable configuration
  An XML file that configures some settings for the search dialog or widget. It includes settings
for features such as voice search, search suggestion, and hint text for the search box.
A searchable activity
  The Activity that receives the search query, searches your
data, and displays the search results.
A search interface, provided by either:
    
The search dialog
        By default, the search dialog is hidden, but appears at the top of the screen when
          you call onSearchRequested() (when the user presses your
          Search button).

Or, a SearchView widget
        Using the search widget allows you to put the search box anywhere in your activity.
Instead of putting it in your activity layout, you should usually use
SearchView as an action view in the app bar.




The rest of this document shows you how to create the searchable configuration, searchable
activity, and implement a search interface with either the search dialog or search widget.
Creating a Searchable Configuration
The first thing you need is an XML file called the searchable configuration. It configures
certain UI aspects of the search dialog or widget and defines how features such as suggestions and
voice search behave. This file is traditionally named searchable.xml and must be saved in
the res/xml/ project directory.
Note: The system uses this file to instantiate a SearchableInfo object, but you cannot create this object yourself at
runtime—you must declare the searchable configuration in XML.
The searchable configuration file must include the <searchable> element as the root node and specify one
or more attributes. For example:

<?xml version="1.0" encoding="utf-8"?>
<searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/app_label"
    android:hint="@string/search_hint" >
</searchable>

The android:label attribute is the only required attribute. It points to a string
resource, which should be the application name. This label isn't actually visible to the
user until you enable search suggestions for Quick Search Box. At that point, this label is visible
in the list of Searchable items in the system Settings.
Though it's not required, we recommend that you always include the android:hint
attribute, which provides a hint string in the search box before users
enter a query. The hint is important because it provides important clues to users about what
they can search.
Tip: For consistency among other
Android applications, you should format the string for android:hint as "Search
<content-or-product>". For example, "Search songs and artists" or "Search
YouTube".
The <searchable> element accepts several other attributes. However, you don't need
most attributes until you add features such as search suggestions
and voice search. For detailed information about the searchable
configuration file, see the Searchable Configuration reference
document.
Creating a Searchable Activity
A searchable activity is the Activity in your application that performs
searches based on a query string and presents the search results.
When the user executes a search in the search dialog or widget, the system starts your
searchable activity and delivers it the search query in an Intent with the  ACTION_SEARCH action. Your
searchable activity retrieves the query from the intent's QUERY extra, then searches your data and presents the results.
Because you may include the search dialog or widget in any other activity in your application,
the system must know which activity is your searchable activity, so it can properly deliver the
search query. So, you must first declare your searchable activity in the Android manifest file.
Declaring a searchable activity
If you don't have one already, create an Activity that will perform
searches and present results. You don't need to implement the search functionality yet—just
create an activity that you can declare in the manifest. Inside the manifest's <activity>
element:

Declare the activity to accept the ACTION_SEARCH intent, in an
<intent-filter>
element.
Specify the searchable configuration to use, in a <meta-data>
element.

For example:

<application ... >
    <activity android:name=".SearchableActivity" >
        <intent-filter>
            <action android:name="android.intent.action.SEARCH" />
        </intent-filter>
        <meta-data android:name="android.app.searchable"
                   android:resource="@xml/searchable"/>
    </activity>
    ...
</application>

The <meta-data> element must include the android:name attribute with a
value of "android.app.searchable" and the android:resource attribute with a
reference to the searchable configuration file (in this example, it
refers to the res/xml/searchable.xml file).
Note: The <intent-filter> does not need a <category> with the
DEFAULT value (which you usually see in <activity> elements),
because the system delivers the ACTION_SEARCH intent explicitly to
your searchable activity, using its component name.
Performing a search
Once you have declared your searchable activity in the manifest, performing a search in your
searchable activity involves three steps:

Receiving the query
Searching your data
Presenting the results

Traditionally, your search results should be presented in a ListView, so
you might want your searchable activity to extend ListActivity. It includes
a default layout with a single ListView and provides several
convenience methods for working with the ListView.
Receiving the query
When a user executes a search from the search dialog or widget, the system starts your
searchable activity and sends it a ACTION_SEARCH intent. This intent
carries the search query in the
QUERY string extra. You must check for
this intent when the activity starts and extract the string. For example, here's how you can get the
search query when your searchable activity starts:

Kotlin

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.search)

    // Verify the action and get the query
    if (Intent.ACTION_SEARCH == intent.action) {
        intent.getStringExtra(SearchManager.QUERY)?.also { query ->
            doMySearch(query)
        }
    }
}

Java

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.search);

    // Get the intent, verify the action and get the query
    Intent intent = getIntent();
    if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
      String query = intent.getStringExtra(SearchManager.QUERY);
      doMySearch(query);
    }
}



The QUERY string is always included with
the ACTION_SEARCH intent. In this example, the query is
retrieved and passed to a local doMySearch() method where the actual search operation
is done.
Searching your data
The process of storing and searching your data is unique to your application.
You can store and search your data in many ways, but this guide does not show you how to store your
data and search it. Storing and searching your data is something you should carefully consider in
terms of your needs and your data format. However, here are some tips you might be able to
apply:

If your data is stored in a SQLite database on the device, performing a full-text search
(using FTS3, rather than a LIKE query) can provide a more robust search across text data and
can produce results significantly faster. See sqlite.org
for information about FTS3 and the SQLiteDatabase class for
information about SQLite on Android. Also look at the Searchable Dictionary sample
application to see a complete SQLite implementation that performs searches with FTS3.
If your data is stored online, then the perceived search performance might be
inhibited by the user's data connection. You might want to display a spinning progress wheel until
your search returns. See android.net for a reference of network APIs and Creating a Progress Dialog
for information about how to display a progress wheel.

Presenting the results
Regardless of where your data lives and how you search it, we recommend that you return search
results to your searchable activity with an Adapter. This way, you can easily
present all the search results in a ListView. If your data comes from a
SQLite database query, you can apply your results to a ListView
using a CursorAdapter. If your data comes in some other type of format, then
you can create an extension of BaseAdapter.
An Adapter binds each item from a set of data into a
View object. When the Adapter
is applied to a ListView, each piece of data is inserted as an individual
view into the list. Adapter is just an interface, so implementations such as CursorAdapter (for binding data from a Cursor) are needed.
If none of the existing implementations work for your data, then you can implement your own from
BaseAdapter. Install the SDK Samples package for API Level 4 to see the
original version of the Searchable Dictionary, which creates a custom adapter to read data from
a file.
You might want your searchable activity to extend
ListActivity. You can then call
setListAdapter(),
passing it an Adapter that is bound to your data. This
injects all the search results into the activity
ListView.
For more help presenting your results in a list, see the ListActivity
documentation.
Also see the Searchable Dictionary sample
for an a complete demonstration of how to search an SQLite database and use an
Adapter to provide results in a ListView.
Using the Search Dialog
The search dialog provides a floating search box at the top of the screen, with the application
icon on the left. The search dialog can provide search suggestions as the user types and, when
the user executes a search, the system sends the search query to a
searchable activity that performs the search. However, if you are developing
your application for devices running Android 3.0, you should consider using the search widget
instead (see Using the Search Widget section).
The search dialog is always hidden by default, until the user activates it. Your application
can activate the search dialog by calling onSearchRequested(). However, this method doesn't work
until you enable the search dialog for the activity.
To enable the search dialog, you must indicate to the system which searchable activity should
receive search queries from the search dialog, in order to perform searches. For example, in the
previous section about Creating a Searchable Activity, a
searchable activity named SearchableActivity was created. If you want a separate activity,
named OtherActivity, to show the search dialog and deliver searches to SearchableActivity, you must declare in the manifest that SearchableActivity is the
searchable activity to use for the search dialog in OtherActivity.
To declare the searchable activity for an activity's search dialog,
add a <meta-data>
element inside the respective activity's <activity> element.
The <meta-data>
element must include the android:value attribute that specifies the searchable activity's
class name and the android:name attribute with a value of "android.app.default_searchable".
For example, here is the declaration for
both a searchable activity, SearchableActivity, and another activity, OtherActivity, which uses SearchableActivity to perform searches executed from its
search dialog:

<application ... >
    <!-- this is the searchable activity; it performs searches -->
    <activity android:name=".SearchableActivity" >
        <intent-filter>
            <action android:name="android.intent.action.SEARCH" />
        </intent-filter>
        <meta-data android:name="android.app.searchable"
                   android:resource="@xml/searchable"/>
    </activity>

    <!-- this activity enables the search dialog to initiate searches
         in the SearchableActivity -->
    <activity android:name=".OtherActivity" ... >
        <!-- enable the search dialog to send searches to SearchableActivity -->
        <meta-data android:name="android.app.default_searchable"
                   android:value=".SearchableActivity" />
    </activity>
    ...
</application>

Because the OtherActivity now includes a <meta-data>
element to declare which searchable activity to use for searches, the activity has enabled the
search dialog.
While the user is in this activity, the onSearchRequested() method activates the search dialog.
When the user executes the search, the system starts SearchableActivity and delivers it
the ACTION_SEARCH intent.
Note: The searchable activity itself provides the search dialog
by default, so you don't need to add this declaration to SearchableActivity.
If you want every activity in your application to provide the search dialog, insert the above <meta-data>
element as a child of the <application>
element, instead of each <activity>. This
way, every activity inherits the value, provides the search dialog, and delivers searches to
the same searchable activity. (If you have multiple searchable activities, you can override the
default searchable activity by placing a different <meta-data>
declaration inside individual activities.)
With the search dialog now enabled for your activities, your application is ready to perform
searches.
Invoking the search dialog
Although some devices provide a dedicated Search button, the behavior of the button may vary
between devices and many devices do not provide a Search button at all. So when using the search
dialog, you must provide a search button in your UI that activates the search
dialog by calling onSearchRequested().
For instance, you should add a Search button in your Options Menu or UI
layout that calls onSearchRequested(). For consistency with
the Android system and other apps, you should label your button with the Android Search icon that's
available from the Action Bar
Icon Pack.
Note: If your app uses an app bar, then you should not use
the search dialog for your search interface. Instead, use the search
widget as a collapsible view in the app bar.
You can also enable "type-to-search" functionality, which activates the search dialog when the
user starts typing on the keyboard—the keystrokes are inserted into the search dialog. You can
enable type-to-search in your activity by calling
setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL) during your activity's
onCreate() method.
The impact of the search dialog on your activity lifecycle
The search dialog is a Dialog that floats at the top of the
screen. It does not cause any change in the activity stack, so when the search dialog appears, no
lifecycle methods (such as onPause()) are called. Your activity just
loses input focus, as input focus is given to the search dialog.

If you want to be notified when the search dialog is activated, override the onSearchRequested() method. When the system calls this method, it is an
indication that your activity has lost input focus to the search dialog, so you can do any
work appropriate for the event (such as pause
a game). Unless you are passing search context data
(discussed below), you should end the method by calling the super class implementation. For
example:

Kotlin

override fun onSearchRequested(): Boolean {
    pauseSomeStuff()
    return super.onSearchRequested()
}

Java

@Override
public boolean onSearchRequested() {
    pauseSomeStuff();
    return super.onSearchRequested();
}



If the user cancels search by pressing the Back button, the search dialog closes and the
activity
regains input focus. You can register to be notified when the search dialog is
closed with setOnDismissListener()
and/or setOnCancelListener(). You
should need to register only the OnDismissListener, because it is called every time the search dialog closes. The OnCancelListener only pertains to events in which the
user explicitly exited the search dialog, so it is not called when a search is executed (in which
case, the search dialog naturally disappears).
If the current activity is not the searchable activity, then the normal activity lifecycle
events are triggered once the user executes a search (the current activity receives onPause() and so forth, as
described in the Activities
document). If, however, the current activity is the searchable activity, then one of two
things happens:

By default, the searchable activity receives the ACTION_SEARCH intent with a call to onCreate() and a new instance of the
activity is brought to the top of the activity stack. There are now two instances of your
searchable activity in the activity stack (so pressing the Back button goes back to the
previous
instance of the searchable activity, rather than exiting the searchable activity).
If you set android:launchMode to "singleTop", then the
searchable activity receives the ACTION_SEARCH intent with a call
to onNewIntent(Intent), passing the new ACTION_SEARCH intent here. For example, here's how you might handle
this case, in which the searchable activity's launch mode is "singleTop":

Kotlin

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.search)
    handleIntent(intent)
}

override fun onNewIntent(intent: Intent) {
    setIntent(intent)
    handleIntent(intent)
}

private fun handleIntent(intent: Intent) {
    if (Intent.ACTION_SEARCH == intent.action) {
        intent.getStringExtra(SearchManager.QUERY)?.also { query ->
            doMySearch(query)
        }
    }
}

Java

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.search);
    handleIntent(getIntent());
}

@Override
protected void onNewIntent(Intent intent) {
    setIntent(intent);
    handleIntent(intent);
}

private void handleIntent(Intent intent) {
    if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
      String query = intent.getStringExtra(SearchManager.QUERY);
      doMySearch(query);
    }
}



Compared to the example code in the section about Performing a
Search, all the code to handle the
search intent is now in the handleIntent() method, so that both onCreate() and onNewIntent() can execute it.
When the system calls onNewIntent(Intent), the activity has
not been restarted, so the getIntent() method
returns the same intent that was received with onCreate(). This is why you should call setIntent(Intent) inside onNewIntent(Intent) (so that the intent saved by the activity is updated in
case you call getIntent() in the future).


The second scenario using "singleTop" launch mode is usually ideal, because chances
are good that once a search is done, the user will perform additional searches and it's a bad
experience if your application creates multiple instances of the searchable activity. So, we
recommend that you set your searchable activity to "singleTop" launch mode in the
application manifest. For example:

<activity android:name=".SearchableActivity"
          android:launchMode="singleTop" >
    <intent-filter>
        <action android:name="android.intent.action.SEARCH" />
    </intent-filter>
    <meta-data android:name="android.app.searchable"
                      android:resource="@xml/searchable"/>
  </activity>

Passing search context data
In some cases, you can make necessary refinements to the search query inside the searchable
activity, for every search made. However, if you want to refine your search criteria based on the
activity from which the user is performing a search, you can provide additional data in the intent
that the system sends to your searchable activity. You can pass the additional data in the APP_DATA Bundle, which is included in the ACTION_SEARCH intent.
To pass this kind of data to your searchable activity, override the onSearchRequested() method for the activity from which the user can perform a
search, create a Bundle with the additional data, and call startSearch() to activate the search dialog.
For example:

Kotlin

override fun onSearchRequested(): Boolean {
    val appData = Bundle().apply {
        putBoolean(JARGON, true)
    }
    startSearch(null, false, appData, false)
    return true
}

Java

@Override
public boolean onSearchRequested() {
     Bundle appData = new Bundle();
     appData.putBoolean(SearchableActivity.JARGON, true);
     startSearch(null, false, appData, false);
     return true;
 }



Returning "true" indicates that you have successfully handled this callback event and
called startSearch() to activate
the search dialog. Once the user submits a query, it's delivered to your
searchable activity along with the data you've added. You can extract the extra data from the APP_DATA Bundle to refine the search. For example:

Kotlin

val jargon: Boolean = intent.getBundleExtra(SearchManager.APP_DATA)?.getBoolean(JARGON) ?: false

Java

Bundle appData = getIntent().getBundleExtra(SearchManager.APP_DATA);
if (appData != null) {
    boolean jargon = appData.getBoolean(SearchableActivity.JARGON);
}



Caution: Never call the startSearch() method from outside
the onSearchRequested() callback method. To activate the search dialog
in your activity, always call onSearchRequested(). Otherwise, onSearchRequested() is not called and customizations (such as the addition of
appData in the above example) are missed.
Using the Search Widget


Figure 2. The SearchView widget as an "action view" in the Action Bar.

The SearchView widget is available in Android 3.0 and higher. If
you're developing your application for Android 3.0 and have decided to use the search widget, we
recommend that you insert the search widget as an action view in the app bar,
instead of using the search dialog (and instead of placing the search widget in your activity
layout). For example, figure 2 shows the search widget in the app bar.
The search widget provides the same functionality as the search dialog. It starts the appropriate
activity when the user executes a search, and it can provide search suggestions and perform voice
search. If it's not an option for you to put the search widget in the Action Bar, you can instead
put the search widget somewhere in your activity layout.
Note: When you use the search widget as an action view, you
still might need to support using the search dialog, for cases in which the search widget does
not fit in the Action Bar. See the following section about Using both
the widget and the dialog.
Configuring the search widget
After you've created a  searchable configuration and a searchable activity, as discussed above, you need to enable assisted
search for each SearchView. You can do so by calling setSearchableInfo() and passing it the SearchableInfo object that represents your searchable configuration.
You can get a reference to the SearchableInfo by calling getSearchableInfo() on SearchManager.
For example, if you're using a SearchView as an action view in the
app bar, you should enable the widget
during the onCreateOptionsMenu() callback:

Kotlin

override fun onCreateOptionsMenu(menu: Menu): Boolean {
    // Inflate the options menu from XML
    val inflater = menuInflater
    inflater.inflate(R.menu.options_menu, menu)

    // Get the SearchView and set the searchable configuration
    val searchManager = getSystemService(Context.SEARCH_SERVICE) as SearchManager
    (menu.findItem(R.id.menu_search).actionView as SearchView).apply {
        // Assumes current activity is the searchable activity
        setSearchableInfo(searchManager.getSearchableInfo(componentName))
        setIconifiedByDefault(false) // Do not iconify the widget; expand it by default
    }

    return true
}

Java

@Override
public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the options menu from XML
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.options_menu, menu);

    // Get the SearchView and set the searchable configuration
    SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
    SearchView searchView = (SearchView) menu.findItem(R.id.menu_search).getActionView();
    // Assumes current activity is the searchable activity
    searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));
    searchView.setIconifiedByDefault(false); // Do not iconify the widget; expand it by default

    return true;
}



That's all you need. The search widget is now configured and the system will deliver search
queries to your searchable activity. You can also enable search
suggestions for the search widget.
Note: If you want to handle all user input yourself, you can do so
with some callback methods and event listeners. For more information, see the reference
documentation for SearchView and its nested interfaces for the
appropriate event listeners.
For more information about action views in the Action Bar, see
Action Views and Action Providers.
Other search widget features
The SearchView widget allows for a few additional features you might
want:

A submit button
By default, there's no button to submit a search query, so the user must press the
"Return" key on the keyboard to initiate a search. You can add a "submit" button by calling
setSubmitButtonEnabled(true).
Query refinement for search suggestions
When you've enabled search suggestions, you usually expect users to simply select a
suggestion, but they might also want to refine the suggested search query. You can add a button
alongside each suggestion that inserts the suggestion in the search box for refinement by the
user, by calling setQueryRefinementEnabled(true).
The ability to toggle the search box visibility
By default, the search widget is "iconified," meaning that it is represented only by a
search icon (a magnifying glass), and expands to show the search box when the user touches it.
As shown above, you can show the search box by default, by calling setIconifiedByDefault(false). You can also
toggle the search widget appearance by calling setIconified().

There are several other APIs in the SearchView class that allow you to
customize the search widget. However, most of them are used only when you handle all
user input yourself, instead of using the Android system to deliver search queries and display
search suggestions.
Using both the widget and the dialog
If you insert the search widget in the Action Bar as an action view, and you enable it to
appear in the Action Bar "if there is room" (by setting android:showAsAction="ifRoom"), then there is a chance that the search widget will not appear
as an action view, but the menu item will appear in the overflow menu. For example, when your
application runs on a smaller screen, there might not be enough room in the Action Bar to display
the search widget along with other action items or navigation elements, so the menu item will
instead appear in the overflow menu. When placed in the overflow menu, the item works like an
ordinary menu item and does not display the action view (the search widget).
To handle this situation, the menu item to which you've attached the search widget should
activate the search dialog when the user selects it from the overflow menu. In order for it to do
so, you must implement onOptionsItemSelected() to
handle the "Search" menu item and open the search dialog by calling onSearchRequested().
For more information about how items in the Action Bar work and how to handle this situation, see
the Action
Bar developer guide.
Also see the Searchable Dictionary for an example implementation using
both the dialog and the widget.
Adding Voice Search
You can add voice search functionality to your search dialog or widget by adding the android:voiceSearchMode attribute to your searchable configuration. This adds a voice search
button that launches a voice prompt. When the user
has finished speaking, the transcribed search query is sent to your searchable
activity.
For example:

<?xml version="1.0" encoding="utf-8"?>
<searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/search_label"
    android:hint="@string/search_hint"
    android:voiceSearchMode="showVoiceSearchButton|launchRecognizer" >
</searchable>

The value showVoiceSearchButton is required to enable voice
search, while the second value, launchRecognizer, specifies that the voice search button
should launch a recognizer that returns the transcribed text to the searchable activity.
You can provide additional attributes to specify the voice search behavior, such
as the language to be expected and the maximum number of results to return. See the Searchable Configuration reference for more information about the
available attributes.
Note: Carefully consider whether voice search is appropriate for
your application. All searches performed with the voice search button are immediately sent to
your searchable activity without a chance for the user to review the transcribed query. Sufficiently
test the voice recognition and ensure that it understands the types of queries that
the user might submit inside your application.
Adding Search Suggestions


Figure 3. Screenshot of a search dialog with custom
search suggestions.

Both the search dialog and the search widget can provide search suggestions as the user
types, with assistance from the Android system. The system manages the list of suggestions and
handles the event when the user selects a suggestion.
You can provide two kinds of search suggestions:

Recent query search suggestions
These suggestions are simply words that the user previously used as search queries in
your application.
  See Adding Recent Query
Suggestions.
Custom search suggestions
These are search suggestions that you provide from your own data source, to help users
immediately select the correct spelling or item they are searching for. Figure 3 shows an
example of custom suggestions for a dictionary application—the user can select a suggestion
to instantly go to the definition.
  See Adding Custom
Suggestions






        
        Next
      


          arrow_forward
        
        Adding recent query suggestions
      




Content and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates.

      
      Last updated January 17, 2019.
    





          
          
            Twitter
          
        Follow @AndroidDev on Twitter
          
          
            YouTube
          
        Check out Android Developers on YouTubeMore Android
                Android
            
                Enterprise
            
                Security
            
                Source
            Support
                Report platform bug
            
                Report documentation bug
            
                Google Play support
            
                Join user studies
            Documentation
                Developer guides
            
                Design guides
            
                API reference
            
                Samples
            
                Android Studio
            
                Android
            
                Chrome
            
                Firebase
            
                Google Cloud Platform
            
                All Products
            
            Bahasa Indonesia
          
            Deutsch
          
            English
          
            español
          
            Español (América Latina)
          
            français
          
            Português Brasileiro
          
            Tiếng Việt
          
            Türkçe
          
            Русский
          
            ภาษาไทย
          
            日本語
          
            简体中文
          
            繁體中文
          
            한국어
          Privacy
         License
         Brand Guidelines
         
        Get Android and Google Play news by email
      
        
        Subscribe
      
