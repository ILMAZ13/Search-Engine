Copy and Paste  |  Android DevelopersAndroid Developers
          Platform
        
          Android Studio
        
          Google Play
        
          Android Jetpack
        
          Docs
        
          News
        
    
    
    
      Documentation
    
    
  
          Overview
        
          Guides
        
          Reference
        
          Samples
        
          Design & Quality
        







          Platform
        



          Android Studio
        



          Google Play
        



          Android Jetpack
        



          Docs
        




          Overview
        



          Guides
        



          Reference
        



          Samples
        



          Design & Quality
        






          News
        












App BasicsIntroductionBuild your first appOverviewCreate an Android projectRun your appBuild a simple user interfaceStart another activityApp fundamentalsApp resourcesOverviewHandle configuration changesLocalizationLocalize your appTest your app with pseudolocalesUnicode and internationalization supportLanguage and locale resolutionComplex XML resourcesResource typesOverviewAnimationColor state listDrawableLayoutMenuStringStyleFontMore typesApp manifest fileOverview<action><activity><activity-alias><application><category><compatible-screens><data><grant-uri-permission><instrumentation><intent-filter><manifest><meta-data><path-permission><permission><permission-group><permission-tree><provider><receiver><service><supports-gl-texture><supports-screens><uses-configuration><uses-feature><uses-library><uses-permission><uses-permission-sdk-23><uses-sdk>App permissionsOverviewRequest app permissionsApp permissions best practicesDefine custom permissionsDevicesDevice compatibilityOverviewScreen compatibility overviewSupport different screen sizesSupport different pixel densitiesSupport display cutoutsDeclare restricted screen supportMultiple APK supportOverviewCreate multiple APKs for different API levelsCreate multiple APKs for different screen sizesCreate multiple APKs for different GL texturesCreate multiple APKs with several dimensionsSupport different languages and culturesSupport different platform versionsFilters on Google PlayWearOverviewAdding wearable features to notificationsOverviewCreating a notificationNotification stylesBridging mode for notificationsMaintaining compatibilityCreating wearable appsOverviewCreating and running a wearable appStandalone appsCreating custom layoutsKeeping your app visibleAuthentication in WearAdding voice capabilitiesPackaging and distributing Wear appsDebugging a Wear appCapturing Wear UI screenshotsCreating Wear apps for ChinaCreating custom UIsOverviewDefining layoutsCreating listsShowing confirmationsExiting full-screen activitiesUsing the Wear UI libraryWear navigation and actionsMulti-function buttonsRotary inputCreating input method editorsUsing wrist gesturesSending and syncing dataOverviewNetwork access and syncingAccessing the wearable data layerSyncing data itemsTransferring assetsSending and receiving messagesHandling data layer eventsMigrating Wear apps to GoogleApiCreating data providersOverviewExpose data to complicationsCreating watch facesOverviewDesigning watch facesBuilding a watch face serviceDrawing watch facesWatch face complicationsExposing data to complicationsAdding complications to a watch faceCreating interactive watch facesProviding configuration activitiesAddressing common issuesOptimizing watch facesDetecting locationRequesting PermissionsUsing the SpeakerAndroid TVOverviewBuilding TV AppsOverviewGetting started with TV appsHandling TV hardwareManaging TV controllersBuilding TV layoutsCreating TV navigationBuilding TV playback appsOverviewCreating a catalog browserProviding a card viewBuilding a details viewUsing Leanback transport controlsDisplaying a now playing cardAdding a guided stepIntroducing first-time users to your appEnabling background playbackHelping users find content on TVOverviewRecommending TV contentOverviewChannels on the home screenVideo program attributesAudio program attributesGame program attributesWatch next attributesPreviewing videosRecommendations in Android N and earlierMaking TV apps searchableSearching within TV AppsBuilding TV gamesBuilding TV channelsOverviewDeveloping a TV input serviceWorking with channel dataManaging user interactionSupporting time-shiftingSupporting content recordingTV Apps checklistAndroid AutoOverviewGetting Started with AutoPlaying Audio for AutoMessaging for AutoTesting for AutoAndroid ThingsOverviewPlatform differencesGoogle servicesSupported hardwareDeveloper kitsGet startedNXP i.MX7DRaspberry Pi 3Advanced setupOverviewManually flash an imageRecover a deviceConnecting to Wi-Fi with adbBuild appsCreate a Things appOverviewCreate a projectConnect the hardwareInteract with peripheralsIntegrate peripheral driversCommunicate with wireless devicesBluetoothLoWPANConfigure devicesSettingsUpdatesInteract with peripheralsOverviewGPIOPWMI2CSPIUARTNative PIOCLI toolIntegrate native codeBuild user-space driversOverviewLocationInputSensorsLoWPANSamplesManage devicesOverviewCreate a productConfigure a productCreate a buildOverviewManage appsPush an updateOverviewAutomatic updatesMonitor analyticsTermsConsole Terms of ServiceSDK License AgreementAndroid Things ConsoleChrome OS devicesOverviewBuilding apps for Chrome OSPreparing your development environmentOptimizing Apps for Chrome OSResolving Issues with Screen SizeApp Manifest Compatibility for ChromebooksLoading Apps on ChromebooksChrome OS Device Support for AppsApp Rendering Differences on ChromebooksWindow managementInput compatibility for ChromebooksAndroid Studio on Chrome OSChrome OS devices on EmulatorTest Cases for Android Apps on Chrome OSCore topicsActivitiesIntroduction to activitiesThe activity lifecycleActivity state changesTest your activitiesTasks and back stackProcesses and app lifecycleParcelables and bundlesFragmentsOverviewCreate a fragmentTest your fragmentsBuild a flexible UICommunicate with other fragmentsInteract with other appsOverviewSending the user to another appGetting a result from an activityAllowing other apps to start your activityHandling app linksOverviewEnabling links to app contentVerify app linksCreate app links for instant appsLoadersRecents screenMulti-window supportApp shortcutsOverviewCreate shortcutsManage shortcutsBest practices for shortcutsApp widgetsOverviewBuild an app widgetBuild an app widget hostArchitecture ComponentsOverviewAdding Components to your ProjectData Binding LibraryOverviewGet startedLayouts and binding expressionsWork with observable data objectsGenerated binding classesBinding adaptersBind layout views to Architecture ComponentsTwo-way data bindingHandling LifecyclesLiveDataNavigationOverviewImplement NavigationUpdate UI components with NavigationUINested graphsPass data between destinationsAdd support for new destinationImplement conditional navigationCreate a deep link for a destinationGlobal actionsMigrate to the Navigation ComponentPaging LibraryOverviewUI Components and ConsiderationsData Components and ConsiderationsRoom Persistence LibraryViewModelWorkManagerOverviewBasicsAdvancedMigrating from Firebase JobDispatcherSaving StatesRelease notesIntents and intent filtersOverviewCommon intentsUser interface & navigationOverviewLayoutsOverviewBuild a responsive UI with ConstraintLayoutCreate a list with RecyclerViewCreate a card-based layoutImplementing adaptive UI flowsImproving layout performanceOverviewOptimizing layout hierarchiesRe-using layouts with <include/>Delayed loading of viewsMaking ListView scrolling smoothLinear layoutAdapter viewRelative layoutCustom view componentsOverviewCreating a custom view classImplementing custom drawingMaking the view interactiveOptimizing the viewLook and feelMaterial designStyles and themesAdaptive iconsAdd a floating action buttonCreate shadows and clip viewsTextAutosizing TextViewsDownloadable fontsFonts in XMLEmoji compatibilityMagnifier widgetSpansButtonsCheckboxesRadio buttonsToggle buttonsSpinnersPickersTooltipsNotificationsOverviewCreate a notificationCreate an expandable notificationStart an activity from a notificationCreate a group of notificationsCreate and manage notification channelsModify a notification BadgeCreate a custom notificationAdd the app barOverviewSet up the app barAdd and handle actionsAdd an up actionUse action views and action providersControl the system UI visibilityOverviewDim the system barsHide the status barHide the navigation barEnable fullscreen modeRespond to UI visibility changesDesigning effective navigationOverviewPlanning screens and their relationshipsPlanning for multiple touchscreen sizesProviding descendant and lateral navigationDesigning back and up navigationPutting it all together: wireframing the example appImplementing effective navigationOverviewCreating swipe views with tabsCreating a navigation drawerProviding up navigationProviding proper back navigationImplementing descendant navigationSlide between fragments using ViewPagerSupporting swipe-to-refreshOverviewAdding swipe-to-refresh to your appResponding to a refresh gestureToasts overviewPop-up messages overviewOverviewBuild and display a pop-up messageAdd an action to a messageDialogsMenusSettingsOverviewOrganize your settingsCustomize your settingsUse saved valuesBuild a hierarchy in codeHandle other form factorsPreference components and attributesSearchOverviewCreating a search interfaceAdding recent query suggestionsAdding custom suggestionsSearchable configurationAdding search functionalityOverviewSetting up the search interfaceStoring and searching for dataRemaining backward compatibleCopy and pasteDrag and dropCreating backward-compatible UIsOverviewAbstracting the new APIsProxying to the new APIsCreating an implementation with older APIsUsing the version-aware componentAnimations & transitionsOverviewAnimations overviewProperty animation overviewAnimate drawable graphicsReveal or hide a view using animationMove a view using animationMove a view using a fling animationEnlarge a view using a zoom animationAnimate movement using spring physicsAuto animate layout updatesAnimate layout changes using a transitionCreate a custom transition animationStart an activity using an animationImages & graphicsOverviewDrawables overviewVector drawables overviewHandling bitmapsSelecting colors with the palette APIReducing image download sizesHardware accelerationOpenGL ESDisplaying graphics with OpenGL ESOverviewBuilding an OpenGL ES environmentDefining shapesDrawing shapesApplying projection and camera viewsAdding motionResponding to touch eventsRenderingOverviewReducing overdrawPerformance and view hierarchiesAnalyzing with profile GPU renderingEnhancing graphics with wide color contentAudio & videoAudio & video overviewSupported media formatsMedia app architectureMedia app architecture overviewUsing a media sessionBuilding an audio appAudio app overviewBuilding a media browser serviceBuilding a media browser clientMedia session callbacksBuilding a video appVideo app overviewBuilding a video player activityMedia session callbacksResponding to media buttonsHandling changes in audio outputManaging audio focusThe Google Assistant and media appsRouting between devicesRouting overviewMediaRouter overviewMediaRouteProvider overviewControl amplitude with VolumeShaperMediaPlayer overviewMediaRecorder overviewExoPlayerBackground tasksOverviewGuide to background processingSending operations to multiple threadsOverviewSpecify the code to run on a threadCreate a manager for multiple threadsRun code on a thread pool threadCommunicate with the UI threadSchedule jobs intelligentlyServicesOverviewCreate a background serviceSend work requests to the background serviceReport work statusBound servicesAIDL overviewBackground optimizationsBroadcasts overviewImplicit Broadcast ExceptionsManage device awake stateOverviewKeep the device awakeSchedule repeating alarmsApp data & filesOverviewStorage overviewSave files on device storageSave key-value dataSave data in a local databaseOverviewDefine data using entitiesCreate views into a databaseAccess data using DAOsMigrate your databaseTest your databaseReference complex dataSharing simple dataOverviewSending simple data to other appsReceiving simple data from other appsAdding an easy share actionSharing filesOverviewSetting up file sharingSharing a fileRequesting a shared fileRetrieving file informationSharing files with NFCOverviewSending files to another deviceReceiving files from another devicePrinting filesOverviewPrinting photosPrinting HTML documentsPrinting custom documentsContent providersOverviewContent provider basicsCreating a content providerOpen files using storage access frameworkCreate a custom document providerApp install locationUser data & identityOverviewAdd sign-in workflowAutofill frameworkOverviewOptimize your app for autofillBuild autofill servicesCalendar provider overviewContacts providerOverviewRetrieving a list of contactsRetrieving details for a contactModifying contacts using intentsDisplaying the quick contact badgeAccount transferData backupOverviewBack up user dataBack up key-value pairsOverviewRegisterTest backup and restoreBest practices for unique identifiersRemember and authenticate usersOverviewRemember your userAuthenticate to OAuth2 servicesCreate a custom account typeUser locationOverviewOptimize location for batteryGet the last known locationChange location settingsReceive location updatesDisplay a location addressCreate and monitor geofencesDetect when users start an activityMigrate to location and context APIsAdd mapsTouch & inputOverviewInput eventsUsing touch gesturesOverviewDetect common gesturesTrack touch and pointer movementsAnimate a scroll gestureHandle multi-touch gesturesDrag and scaleManage touch events in a ViewGroupHandling keyboard inputOverviewSpecifying the input method typeHandling input method visibilitySupporting keyboard navigationHandling keyboard actionsSupporting game controllersOverviewHandling controller actionsSupporting controllers across Android versionsSupporting multiple game controllersInput method editorsCreating an input methodImage keyboardSpelling checkerCameraOverviewTaking photosRecording videosControlling the cameraCamera APISensorsOverviewSensors overviewMotion sensorsPosition sensorsEnvironment sensorsRaw GNSS measurementsConnectivityOverviewPerforming network operationsOverviewConnect to the networkManage network usageOptimize network data usageParse XML dataTransmit network data using VolleyOverviewSend a simple requestSet up RequestQueueMake a standard requestImplement a custom requestPerform network operations using CronetOverviewSend a simple requestCronet request lifecycleReferenceorg.chromium.netOverviewCallbackExceptionCronetEngineOverviewCronetEngine.BuilderOverviewLibraryLoaderCronetExceptionInlineExecutionProhibitedExceptionNetworkExceptionQuicExceptionUploadDataProviderUploadDataProvidersUploadDataSinkUrlRequestOverviewBuilderCallbackStatusStatusListenerUrlResponseInfoOverviewHeaderBlockTransferring data without draining the batteryOverviewOptimize downloads for efficient network accessMinimize the effect of regular updatesAvoid redundant downloadsModify patterns based on the connectivity typeReduce network battery drainOverviewCollecting network traffic dataAnalyzing data trafficOptimizing user-initiated network useOptimizing app-initiated network useOptimizing server-initiated network useOptimizing general network useTransfer data using Sync AdaptersOverviewCreate a Stub AuthenticatorCreate a Stub Content ProviderCreate a Sync AdapterRun a Sync AdapterBluetoothOverviewBluetooth low energy overviewNFCOverviewNFC basicsAdvanced NFCHost-based card emulation overviewTelecomOverviewBuild a calling appWi-FiWi-Fi scanning overviewWi-Fi peer-to-peer overviewWi-Fi aware overviewWi-Fi location with RTTCompanion device pairing overviewUSBOverviewAccessory overviewHost overviewVPNSession initiation protocol overviewDiscover and connectOverviewUse network service discoveryCreate P2P connections with Wi-FiUse Wi-Fi P2P for service discoveryRenderscriptOverviewAdvanced RenderScriptRuntime API referenceOverviewNumerical typesObject typesConversion functionsMathematical constants and functionsVector math functionsMatrix functionsQuaternion functionsAtomic update functionsTime functions and typesAllocation data access functionsObject characteristics functionsKernel invocation functions and typesInput/output functionsDebugging functionsGraphics functions and typesIndexWeb-based contentOverviewBuilding web apps in WebViewManaging WebView objectsMigrating to WebView in Android 4.4Supporting different screens in web appsDebugging web appsBest practices for web appsAndroid App BundlesOverviewDownload modules with the Play Core LibraryGoogle Play InstantOverview of Google Play InstantGet started with instant appsCreate an instant-enabled app bundleUX best practices for appsGet started with instant gamesOverviewUnity pluginTechnical requirements checklist for gamesUX best practices for gamesReduce the size of your instant app or gameAdd ads to your instant app or gameProvide multiple entry pointsIntegrate with FirebaseAdd Google Analytics for Firebase to your instant appUse Firebase Dynamic Links with instant appsGoogle Play Instant policyResourcesReferenceCode samplesSDK release notesSupportFAQsKnown issuesStackOverflowApp ActionsSlicesOverviewGetting StartedSlice templatesBest practicesTestingOverviewFundamentals of testingSet up projectBuilding effective unit testsOverviewBuilding local unit testsBuilding instrumented unit testsAutomating UI testsOverviewTesting UI for a single appTesting UI for multiple appsTesting app component integrationsOverviewTesting your serviceTesting your content providerTesting UI performanceEspressoOverviewSetup instructionsBasicsRecipesMultiprocessAccessibility checkingListsIntentsWebIdling resourceCheat sheetUI AutomatorJUnit4 RulesAndroidJUnitRunnerSamplesRelease notesPerformanceOverviewAndroid VitalsOverviewStuck Partial Wake LocksExcessive WakeupsExcessive Background Wi-Fi ScansExcessive Background Network UsageANRsCrashesSlow RenderingFrozen FramesPermission DenialsApp Startup TimeApp Standby BucketsProcesses and Threads OverviewBetter Performance through ThreadingOptimizing for Battery LifeOverviewOptimizing for Doze and App StandbyMonitoring the Battery Level and Charging StateDetermining and Monitoring the Docking State and TypeDetermining and Monitoring the Connectivity StatusPower Management RestrictionsAnalyzing Power Use with Battery HistorianTesting power-related issuesReducing APK SizeManage Your App's MemoryOverview of Memory ManagemementDesigning for SeamlessnessKeeping Your App ResponsivePerformance TipsSMP Primer for AndroidVerifying App Behavior on the Android Runtime (ART)AccessibilityOverviewMaking apps more accessibleUsing node tree debuggingBuilding accessibility servicesBuild accessible custom viewsBuild accessibility serviceTest your app's accessibilitySecurityApp security best practicesSecurity tipsSecurity with HTTPS and SSLNetwork security configurationUpdating your security provider to protect against SSL exploitsProtecting against security threats with SafetyNetOverviewSafetyNet Attestation APISafetyNet Safe Browsing APISafetyNet reCAPTCHA APISafetyNet Verify Apps APICryptographyAndroid Keystore SystemVerifying hardware-backed key pairs with key attestationAndroid Protected ConfirmationSupporting Direct BootUsing scoped directory accessApp security improvement programBuild for BillionsOverviewConnectivityDevice capabilityData costBattery consumptionUI and contentBuild for EnterpriseOverviewDeveloper guideWork profilesSet up managed configurationsWork contactsDevice management policiesDevice managementOverviewBuild a device policy controllerWork profiles on fully managed devicesDedicated devicesOverviewLock task modeMultiple usersCookbookDevice controlNetworking and telephonySecuritySystem updatesNetwork activity loggingAndroid versionsOverviewAndroid 9Android 8.0Android 7.0Device administrationGoogle PlayGoogle Play BillingOverviewUse the Google Play Billing LibraryOverviewAdd one-time product-specific featuresAdd subscription-specific featuresPlay Billing Library referencePlay Billing Library release notesUse In-app Billing with AIDLOverviewIn-app Billing ReferenceAdd Real-time Developer NotificationsBest PracticesTest Google Play BillingMaking Your App Content Searchable by GoogleOptimizing Contextual Content for the AssistantGoogle Play Developer APIAPK Expansion FilesApplication LicensingOverviewLicensing OverviewSetting Up for LicensingAdding Licensing to Your AppLicensing ReferenceGoogle Play Install ReferrerOverviewPlay Install Referrer LibraryOverviewReferenceReleases NotesPlay Install Referrer API









    
    
      Android Developers
    
    
    




    
    
      Docs
    
    
    




    
    
      Guides
    
    
    




    Copy and Paste
  



    Android provides a powerful clipboard-based framework for copying and pasting. It
    supports both simple and complex data types, including text strings, complex data
    structures, text and binary stream data, and even application assets. Simple text data is stored
    directly in the clipboard, while complex data is stored as a reference that the pasting
    application resolves with a content provider. Copying and pasting works both within an
    application and between applications that implement the framework.


    Since a part of the framework uses content providers, this topic assumes some
    familiarity with the Android Content Provider API, which is described in the topic
    Content Providers.

The Clipboard Framework

    When you use the clipboard framework, you put data into a clip object, and then
    put the clip object on the system-wide clipboard. The clip object can take one of three forms:


Text

            A text string. You put the string directly into the clip object, which you then put onto
            the clipboard. To paste the string, you get the clip object from the clipboard and copy
            the string to into your application's storage.
        
URI

            A Uri object representing any form of URI. This is primarily for
            copying complex data from a content provider. To copy data, you put a
            Uri object into a clip object and put the clip object onto
            the clipboard. To paste the data, you get the clip object, get the
            Uri object, resolve it to a data source such as a content provider,
            and copy the data from the source into your application's storage.
        
Intent

            An Intent. This supports copying application shortcuts. To copy
            data, you create an Intent, put it into a clip object, and put the clip object onto the
            clipboard. To paste the data, you get the clip object and then copy the Intent object
            into your application's memory area.
        


    The clipboard holds only one clip object at a time. When an application puts a clip object on
    the clipboard, the previous clip object disappears.


    If you want to allow users to paste data into your application, you don't have to handle all
    types of data. You can examine the data on the clipboard before you give users the option to
    paste it. Besides having a certain data form, the clip object also contains metadata that tells
    you what MIME type or types are available. This metadata helps you decide if your application
    can do something useful with the clipboard data. For example, if you have an application that
    primarily handles text, you may want to ignore clip objects that contain a URI or Intent.


    You may also want to allow users to paste text regardless of the form of data on the
    clipboard. To do this, you can force the clipboard data into a text representation, and then
    paste this text. This is described in the section Coercing the
    clipboard to text.

Clipboard Classes

    This section describes the classes used by the clipboard framework.

ClipboardManager

    In the Android system, the system clipboard is represented by the global
    ClipboardManager class. You do not instantiate this
    class directly; instead, you get a reference to it by invoking
    getSystemService(CLIPBOARD_SERVICE).

ClipData, ClipData.Item, and ClipDescription

    To add data to the clipboard, you create a ClipData object that
    contains both a description of the data and the data itself. The clipboard holds only one
    ClipData at a time. A ClipData contains a
    ClipDescription object and one or more
    ClipData.Item objects.


    A ClipDescription object contains metadata about the clip. In
    particular, it contains an array of available MIME types for the clip's data. When you put a
    clip on the clipboard, this array is available to pasting applications, which can examine it to
    see if they can handle any of available the MIME types.


    A ClipData.Item object contains the text, URI, or Intent data:


Text

        A CharSequence.
    
URI

        A Uri. This usually contains a content provider URI, although any
        URI is allowed. The application that provides the data puts the URI on the clipboard.
        Applications that want to paste the data get the URI from the clipboard and use it to
        access the content provider (or other data source) and retrieve the data.
    
Intent

        An Intent. This data type allows you to copy an application shortcut
        to the clipboard. Users can then paste the shortcut into their applications for later use.
    


    You can add more than one ClipData.Item object to a clip. This allows
    users to copy and paste multiple selections as a single clip. For example, if you have a list
    widget that allows the user to select more than one item at a time, you can copy all the items
    to the clipboard at once. To do this, you create a separate
    ClipData.Item for each list item, and then you add the
    ClipData.Item objects to the ClipData object.

ClipData convenience methods

    The ClipData class provides static convenience methods for creating
    a ClipData object with a single ClipData.Item
    object and a simple ClipDescription object:



newPlainText(label, text)


        Returns a ClipData object whose single
        ClipData.Item object contains a text string. The
        ClipDescription object's label is set to label.
        The single MIME type in ClipDescription is
        MIMETYPE_TEXT_PLAIN.
        
            Use
newPlainText()
            to create a clip from a text string.
    

newUri(resolver, label, URI)


        Returns a ClipData object whose single
        ClipData.Item object contains a URI. The
        ClipDescription object's label is set to label.
        If the URI is a content URI (Uri.getScheme() returns
        content:), the method uses the ContentResolver object
        provided in resolver to retrieve the available MIME types from the
        content provider and store them in ClipDescription. For a URI that
        is not a content: URI, the method sets the MIME type to
        MIMETYPE_TEXT_URILIST.
        
            Use
newUri()
            to create a clip from a URI, particularly a content: URI.
        


newIntent(label, intent)


        Returns a ClipData object whose single
        ClipData.Item object contains an Intent.
        The ClipDescription object's label is set to label.
        The MIME type is set to MIMETYPE_TEXT_INTENT.
        
            Use
newIntent()
            to create a clip from an Intent object.
    

Coercing the clipboard data to text

    Even if your application only handles text, you can copy non-text data from the
    clipboard by converting it with the method
    ClipData.Item.coerceToText().


    This method converts the data in ClipData.Item to text and
    returns a CharSequence. The value that
    ClipData.Item.coerceToText()
    returns is based on the form of data in ClipData.Item:


Text

        If ClipData.Item is text
        (getText() is not null),
        coerceToText() returns the
        text.
    
URI

        If ClipData.Item is a URI
        (getUri() is not null),
        coerceToText() tries to use
        it as a content URI:
    

                If the URI is a content URI and the provider can return a text stream,
                coerceToText() returns
                a text stream.
            

                If the URI is a content URI but the provider does not offer a text stream,
                coerceToText() returns
                a representation of the URI. The representation is the same as that returned by
                Uri.toString().
            

                If the URI is not a content URI,
                coerceToText() returns
                a representation of the URI. The representation is the same as that returned by
                Uri.toString().
            


Intent

        If ClipData.Item is an Intent
        (getIntent() is not null),
        coerceToText() converts it to
        an Intent URI and returns it. The representation is the same as that returned by
        Intent.toUri(URI_INTENT_SCHEME).
    


    The clipboard framework is summarized in Figure 1. To copy data, an application puts a
    ClipData object on the ClipboardManager global
    clipboard. The ClipData contains one or more
    ClipData.Item objects and one
    ClipDescription object. To paste data, an application gets the
    ClipData, gets its MIME type from the
    ClipDescription, and gets the data either from
    the ClipData.Item or from the content provider referred to by
    ClipData.Item.




Figure 1. The Android clipboard framework

Copying to the Clipboard

    As described previously, to copy data to the clipboard you get a handle to the global
    ClipboardManager object, create a ClipData
    object, add a ClipDescription and one or more
    ClipData.Item objects to it, and add the finished
    ClipData object to the ClipboardManager object.
    This is described in detail in the following procedure:



        If you are copying data using a content URI, set up a content
        provider.
        
            The 
            Note Pad sample application is an example of using a content provider for
            copying and pasting. The

            NotePadProvider class implements the content provider. The

            NotePad class defines a contract between the provider and other applications,
            including the supported MIME types.
        


        Get the system clipboard:

Kotlin

when(menuItem.itemId) {
    ...
    R.id.menu_copy -> { // if the user selects copy
        // Gets a handle to the clipboard service.
        val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
    }
}

Java

...

// if the user selects copy
case R.id.menu_copy:

// Gets a handle to the clipboard service.
ClipboardManager clipboard = (ClipboardManager)
        getSystemService(Context.CLIPBOARD_SERVICE);






            Copy the data to a new ClipData object:
        


For text

Kotlin

// Creates a new text clip to put on the clipboard
val clip: ClipData = ClipData.newPlainText("simple text", "Hello, World!")

Java

// Creates a new text clip to put on the clipboard
ClipData clip = ClipData.newPlainText("simple text", "Hello, World!");





For a URI

                    This snippet constructs a URI by encoding a record ID onto the content URI
                    for the provider. This technique is covered in more detail
                    in the section Encoding an identifier on the URI:
                

Kotlin

// Creates a Uri based on a base Uri and a record ID based on the contact's last name
// Declares the base URI string
const val CONTACTS = "content://com.example.contacts"

// Declares a path string for URIs that you use to copy data
const val COPY_PATH = "/copy"

// Declares the Uri to paste to the clipboard
val copyUri: Uri = Uri.parse("$CONTACTS$COPY_PATH/$lastName")

...

// Creates a new URI clip object. The system uses the anonymous getContentResolver() object to
// get MIME types from provider. The clip object's label is "URI", and its data is
// the Uri previously created.
val clip: ClipData = ClipData.newUri(contentResolver, "URI", copyUri)

Java

// Creates a Uri based on a base Uri and a record ID based on the contact's last name
// Declares the base URI string
private static final String CONTACTS = "content://com.example.contacts";

// Declares a path string for URIs that you use to copy data
private static final String COPY_PATH = "/copy";

// Declares the Uri to paste to the clipboard
Uri copyUri = Uri.parse(CONTACTS + COPY_PATH + "/" + lastName);

...

// Creates a new URI clip object. The system uses the anonymous getContentResolver() object to
// get MIME types from provider. The clip object's label is "URI", and its data is
// the Uri previously created.
ClipData clip = ClipData.newUri(getContentResolver(), "URI", copyUri);





For an Intent

                    This snippet constructs an Intent for an application
                    and then puts it in the clip object:
                

Kotlin

// Creates the Intent
val appIntent = Intent(this, com.example.demo.myapplication::class.java)

...

// Creates a clip object with the Intent in it. Its label is "Intent" and its data is
// the Intent object created previously
val clip: ClipData = ClipData.newIntent("Intent", appIntent)

Java

// Creates the Intent
Intent appIntent = new Intent(this, com.example.demo.myapplication.class);

...

// Creates a clip object with the Intent in it. Its label is "Intent" and its data is
// the Intent object created previously
ClipData clip = ClipData.newIntent("Intent", appIntent);







        Put the new clip object on the clipboard:

Kotlin

// Set the clipboard's primary clip.
clipboard.primaryClip = clip

Java

// Set the clipboard's primary clip.
clipboard.setPrimaryClip(clip);





Pasting from the Clipboard

    As described previously, you paste data from the clipboard by getting the global clipboard
    object, getting the clip object, looking at its data, and if possible copying the data from
    the clip object to your own storage. This section describes in detail how to do this for
    the three forms of clipboard data.

Pasting plain text

    To paste plain text, first get the global clipboard and verify that it can return plain text.
    Then get the clip object and copy its text to your own storage using
    getText(), as described in the following procedure:



        Get the global ClipboardManager object using
 getSystemService(CLIPBOARD_SERVICE). Also
        declare a global variable to contain the pasted text:

Kotlin

var clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
var pasteData: String = ""

Java

ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
String pasteData = "";





        Next, determine if you should enable or disable the "paste" option in the
        current Activity. You should verify that the clipboard contains a clip and that you
        can handle the type of data represented by the clip:

Kotlin

// Gets the ID of the "paste" menu item
val pasteItem: MenuItem = menu.findItem(R.id.menu_paste)

// If the clipboard doesn't contain data, disable the paste menu item.
// If it does contain data, decide if you can handle the data.
pasteItem.isEnabled = when {
    !clipboard.hasPrimaryClip() -> {
        false
    }
    !(clipboard.primaryClipDescription.hasMimeType(MIMETYPE_TEXT_PLAIN)) -> {
        // This disables the paste menu item, since the clipboard has data but it is not plain text
        false
    }
    else -> {
        // This enables the paste menu item, since the clipboard contains plain text.
        true
    }
}

Java

// Gets the ID of the "paste" menu item
MenuItem pasteItem = menu.findItem(R.id.menu_paste);

// If the clipboard doesn't contain data, disable the paste menu item.
// If it does contain data, decide if you can handle the data.
if (!(clipboard.hasPrimaryClip())) {

    pasteItem.setEnabled(false);

} else if (!(clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN))) {

    // This disables the paste menu item, since the clipboard has data but it is not plain text
    pasteItem.setEnabled(false);
} else {

    // This enables the paste menu item, since the clipboard contains plain text.
    pasteItem.setEnabled(true);
}





        Copy the data from the clipboard. This point in the program is only reachable if the
        "paste" menu item is enabled, so you can assume that the clipboard contains
        plain text. You do not yet know if it contains a text string or a URI that points to plain
        text. The following snippet tests this, but it only shows the code for handling plain text:

Kotlin

when (menuItem.itemId) {
    ...
    R.id.menu_paste -> {    // Responds to the user selecting "paste"
        // Examines the item on the clipboard. If getText() does not return null, the clip item
        // contains the text. Assumes that this application can only handle one item at a time.
        val item = clipboard.primaryClip.getItemAt(0)

        // Gets the clipboard as text.
        pasteData = item.text

        return if (pasteData != null) {
            // If the string contains data, then the paste operation is done
            true
        } else {
            // The clipboard does not contain text.
            // If it contains a URI, attempts to get data from it
            val pasteUri: Uri? = item.uri

            if (pasteUri != null) {
                // If the URI contains something, try to get text from it

                // calls a routine to resolve the URI and get data from it. This routine is not
                // presented here.
                pasteData = resolveUri(pasteUri)
                true
            } else {

                // Something is wrong. The MIME type was plain text, but the clipboard does not
                // contain either text or a Uri. Report an error.
                Log.e(TAG,"Clipboard contains an invalid data type")
                false
            }
        }
    }
}

Java

// Responds to the user selecting "paste"
case R.id.menu_paste:

// Examines the item on the clipboard. If getText() does not return null, the clip item contains the
// text. Assumes that this application can only handle one item at a time.
 ClipData.Item item = clipboard.getPrimaryClip().getItemAt(0);

// Gets the clipboard as text.
pasteData = item.getText();

// If the string contains data, then the paste operation is done
if (pasteData != null) {
    return true;

// The clipboard does not contain text. If it contains a URI, attempts to get data from it
} else {
    Uri pasteUri = item.getUri();

    // If the URI contains something, try to get text from it
    if (pasteUri != null) {

        // calls a routine to resolve the URI and get data from it. This routine is not
        // presented here.
        pasteData = resolveUri(Uri);
        return true;
    } else {

        // Something is wrong. The MIME type was plain text, but the clipboard does not contain either
        // text or a Uri. Report an error.
        Log.e(TAG, "Clipboard contains an invalid data type");
        return false;
    }
}





Pasting data from a content URI

    If the ClipData.Item object contains a content URI and you
    have determined that you can handle one of its MIME types, create a
    ContentResolver and then call the appropriate content provider
    method to retrieve the data.


    The following procedure describes how to get data from a content provider based on a
    content URI on the clipboard. It checks that a MIME type that the application can use
    is available from the provider:



        Declare a global variable to contain the MIME type:

Kotlin

// Declares a MIME type constant to match against the MIME types offered by the provider
const val MIME_TYPE_CONTACT = "vnd.android.cursor.item/vnd.example.contact"

Java

// Declares a MIME type constant to match against the MIME types offered by the provider
public static final String MIME_TYPE_CONTACT = "vnd.android.cursor.item/vnd.example.contact";





        Get the global clipboard. Also get a content resolver so you can access the content
        provider:

Kotlin

// Gets a handle to the Clipboard Manager
val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager

// Gets a content resolver instance
val cr = contentResolver

Java

// Gets a handle to the Clipboard Manager
ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

// Gets a content resolver instance
ContentResolver cr = getContentResolver();





        Get the primary clip from the clipboard, and get its contents as a URI:

Kotlin

// Gets the clipboard data from the clipboard
val clip: ClipData? = clipboard.primaryClip

val pasteUri: Uri? = clip?.run {

    // Gets the first item from the clipboard data
    val item: ClipData.Item = getItemAt(0)

    // Tries to get the item's contents as a URI
    item.uri

Java

// Gets the clipboard data from the clipboard
ClipData clip = clipboard.getPrimaryClip();

if (clip != null) {

    // Gets the first item from the clipboard data
    ClipData.Item item = clip.getItemAt(0);

    // Tries to get the item's contents as a URI
    Uri pasteUri = item.getUri();





        Test to see if the URI is a content URI by calling
        getType(Uri). This method returns
        null if Uri does not point to a valid content provider:

Kotlin

    // If the clipboard contains a URI reference
    val  uriMimeType: String? = pasteUri?.let {

        // Is this a content URI?
        cr.getType(it)

Java

    // If the clipboard contains a URI reference
    if (pasteUri != null) {

        // Is this a content URI?
        String uriMimeType = cr.getType(pasteUri);





        Test to see if the content provider supports a MIME type that the current application
        understands. If it does, call
        ContentResolver.query() to get the data. The return value is a
        Cursor:

Kotlin

        // If the return value is not null, the Uri is a content Uri
        uriMimeType?.takeIf {

            // Does the content provider offer a MIME type that the current application can use?
            it == MIME_TYPE_CONTACT
        }?.apply {

            // Get the data from the content provider.
            cr.query(pasteUri, null, null, null, null)?.use { pasteCursor ->

                // If the Cursor contains data, move to the first record
                if (pasteCursor.moveToFirst()) {

                    // get the data from the Cursor here. The code will vary according to the
                    // format of the data model.
                }

                // Kotlin `use` will automatically close the Cursor
            }
        }
    }
}

Java

        // If the return value is not null, the Uri is a content Uri
        if (uriMimeType != null) {

            // Does the content provider offer a MIME type that the current application can use?
            if (uriMimeType.equals(MIME_TYPE_CONTACT)) {

                // Get the data from the content provider.
                Cursor pasteCursor = cr.query(uri, null, null, null, null);

                // If the Cursor contains data, move to the first record
                if (pasteCursor != null) {
                    if (pasteCursor.moveToFirst()) {

                    // get the data from the Cursor here. The code will vary according to the
                    // format of the data model.
                    }
                }

                // close the Cursor
                pasteCursor.close();
             }
         }
     }
}





Pasting an Intent

    To paste an Intent, first get the global clipboard. Examine the
    ClipData.Item object to see if it contains an Intent. Then call
    getIntent() to copy the Intent to your own storage.
    The following snippet demonstrates this:


Kotlin

// Gets a handle to the Clipboard Manager
val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager

// Checks to see if the clip item contains an Intent, by testing to see if getIntent() returns null
val pasteIntent: Intent? = clipboard.primaryClip?.getItemAt(0)?.intent

if (pasteIntent != null) {

    // handle the Intent

} else {

    // ignore the clipboard, or issue an error if your application was expecting an Intent to be
    // on the clipboard
}

Java

// Gets a handle to the Clipboard Manager
ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

// Checks to see if the clip item contains an Intent, by testing to see if getIntent() returns null
Intent pasteIntent = clipboard.getPrimaryClip().getItemAt(0).getIntent();

if (pasteIntent != null) {

    // handle the Intent

} else {

    // ignore the clipboard, or issue an error if your application was expecting an Intent to be
    // on the clipboard
}



Using Content Providers to Copy Complex Data

    Content providers support copying complex data such as database records or file streams.
    To copy the data, you put a content URI on the clipboard. Pasting applications then get this
    URI from the clipboard and use it to retrieve database data or file stream descriptors.


    Since the pasting application only has the content URI for your data, it needs to know which
    piece of data to retrieve. You can provide this information by encoding an identifier for the
    data on the URI itself, or you can provide a unique URI that will return the data you want to
    copy. Which technique you choose depends on the organization of your data.


    The following sections describe how to set up URIs, how to provide complex data, and how to
    provide file streams. The descriptions assume that you are familiar with the general principles
    of content provider design.

Encoding an identifier on the URI

    A useful technique for copying data to the clipboard with a URI is to encode an identifier for
    the data on the URI itself. Your content provider can then get the identifier from the URI and
    use it to retrieve the data. The pasting application doesn't have to know that the identifier
    exists; all it has to do is get your "reference" (the URI plus the identifier) from
    the clipboard, give it your content provider, and get back the data.


    You usually encode an identifier onto a content URI by concatenating it to the end of the URI.
    For example, suppose you define your provider URI as the following string:


"content://com.example.contacts"


   If you want to encode a name onto this URI, you would use the following snippet:


Kotlin

val uriString = "content://com.example.contacts/Smith"

// uriString now contains content://com.example.contacts/Smith.

// Generates a uri object from the string representation
val copyUri = Uri.parse(uriString)

Java

String uriString = "content://com.example.contacts" + "/" + "Smith";

// uriString now contains content://com.example.contacts/Smith.

// Generates a uri object from the string representation
Uri copyUri = Uri.parse(uriString);




    If you are already using a content provider, you may want to add a new URI path that indicates
    the URI is for copying. For example, suppose you already have the following URI paths:


"content://com.example.contacts"/people
"content://com.example.contacts"/people/detail
"content://com.example.contacts"/people/images


   You could add another path that is specific to copy URIs:


"content://com.example.contacts/copying"


    You could then detect a "copy" URI by pattern-matching and handle it with code that
    is specific for copying and pasting.


    You normally use the encoding technique if you're already using a content provider, internal
    database, or internal table to organize your data. In these cases, you have multiple pieces of
    data you want to copy, and presumably a unique identifier for each piece. In response to a
    query from the pasting application, you can look up the data by its identifier and return it.


    If you don't have multiple pieces of data, then you probably don't need to encode an identifier.
    You can simply use a URI that is unique to your provider. In response to a query, your provider
    would return the data it currently contains.


    Getting a single record by ID is used in the
    Note Pad sample application to
    open a note from the notes list. The sample uses the _id field from an SQL
    database, but you can have any numeric or character identifier you want.

Copying data structures

    You set up a content provider for copying and pasting complex data as a subclass of the
    ContentProvider component. You should also encode the URI you put on
    the clipboard so that it points to the exact record you want to provide. In addition, you
    have to consider the existing state of your application:



        If you already have a content provider, you can add to its functionality. You may only
        need to modify its
query()
        method to handle URIs coming from applications that want to paste data. You will
        probably want to modify the method to handle a "copy" URI pattern.
    

        If your application maintains an internal database, you may
        want to move this database into a content provider to facilitate copying from it.
    

        If you are not currently using a database, you can implement a simple content provider
        whose sole purpose is to offer data to applications that are pasting from the
        clipboard.
    


In the content provider, you will want to override at least the following methods:



query()


        Pasting applications will assume that they can get your data by using this method with
        the URI you put on the clipboard. To support copying, you should have this method
        detect URIs that contain a special "copy" path. Your application can then
        create a "copy" URI to put on the clipboard, containing the copy path and
        a pointer to the exact record you want to copy.
    

getType()


        This method should return the MIME type or types for the data you intend to copy. The method
        newUri() calls
        getType() in order to put the MIME
        types into the new ClipData object.
        
            MIME types for complex data are described in the topic
            Content Providers.
        



    Notice that you don't have to have any of the other content provider methods such as
    insert() or
    update().
    A pasting application only needs to get your supported MIME types and copy data from your
    provider. If you already have these methods, they won't interfere with copy operations.


    The following snippets demonsrate how to set up your application to copy complex data:




            In the global constants for your application,
            declare a base URI string and a path that identifies URI strings you are
            using to copy data. Also declare a MIME type for the copied data:
        

Kotlin

// Declares the base URI string
private const val CONTACTS = "content://com.example.contacts"

// Declares a path string for URIs that you use to copy data
private const val COPY_PATH = "/copy"

// Declares a MIME type for the copied data
const val MIME_TYPE_CONTACT = "vnd.android.cursor.item/vnd.example.contact"

Java

// Declares the base URI string
private static final String CONTACTS = "content://com.example.contacts";

// Declares a path string for URIs that you use to copy data
private static final String COPY_PATH = "/copy";

// Declares a MIME type for the copied data
public static final String MIME_TYPE_CONTACT = "vnd.android.cursor.item/vnd.example.contact";





        In the Activity from which users copy data,
        set up the code to copy data to the clipboard. In response to a copy request, put
        the URI on the clipboard:

Kotlin

class MyCopyActivity : Activity() {

    ...

when(item.itemId) {
    R.id.menu_copy -> { // The user has selected a name and is requesting a copy.
        // Appends the last name to the base URI
        // The name is stored in "lastName"
        uriString = "$CONTACTS$COPY_PATH/$lastName"

        // Parses the string into a URI
        val copyUri: Uri? = Uri.parse(uriString)

        // Gets a handle to the clipboard service.
        val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager

        val clip: ClipData = ClipData.newUri(contentResolver, "URI", copyUri)

        // Set the clipboard's primary clip.
        clipboard.primaryClip = clip
    }
}

Java

public class MyCopyActivity extends Activity {

    ...

// The user has selected a name and is requesting a copy.
case R.id.menu_copy:

    // Appends the last name to the base URI
    // The name is stored in "lastName"
    uriString = CONTACTS + COPY_PATH + "/" + lastName;

    // Parses the string into a URI
    Uri copyUri = Uri.parse(uriString);

    // Gets a handle to the clipboard service.
    ClipboardManager clipboard = (ClipboardManager)
        getSystemService(Context.CLIPBOARD_SERVICE);

    ClipData clip = ClipData.newUri(getContentResolver(), "URI", copyUri);

    // Set the clipboard's primary clip.
    clipboard.setPrimaryClip(clip);






        In the global scope of your content provider, create a URI matcher and add a URI
        pattern that will match URIs you put on the clipboard:
    

Kotlin

// A Uri Match object that simplifies matching content URIs to patterns.
private val sUriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {

    // Adds a matcher for the content URI. It matches
    // "content://com.example.contacts/copy/*"
    addURI(CONTACTS, "names/*", GET_SINGLE_CONTACT)
}

// An integer to use in switching based on the incoming URI pattern
private const val GET_SINGLE_CONTACT = 0

...

class MyCopyProvider : ContentProvider() {
    ...
}

Java

public class MyCopyProvider extends ContentProvider {

    ...

// A Uri Match object that simplifies matching content URIs to patterns.
private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);

// An integer to use in switching based on the incoming URI pattern
private static final int GET_SINGLE_CONTACT = 0;

...

// Adds a matcher for the content URI. It matches
// "content://com.example.contacts/copy/*"
sUriMatcher.addURI(CONTACTS, "names/*", GET_SINGLE_CONTACT);






        Set up the
     query()
        method. This method can handle different URI patterns, depending on how you code it, but
        only the pattern for the clipboard copying operation is shown:
    

Kotlin

// Sets up your provider's query() method.
override fun query(
        uri: Uri,
        projection: Array<out String>?,
        selection: String?,
        selectionArgs: Array<out String>?,
        sortOrder: String?
): Cursor? {

    ...

    // when based on the incoming content URI
    when(sUriMatcher.match(uri)) {

        GET_SINGLE_CONTACT -> {

            // query and return the contact for the requested name. Here you would decode
            // the incoming URI, query the data model based on the last name, and return the result
            // as a Cursor.
        }
    }

    ...

}

Java

// Sets up your provider's query() method.
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
    String sortOrder) {

    ...

    // Switch based on the incoming content URI
    switch (sUriMatcher.match(uri)) {

    case GET_SINGLE_CONTACT:

        // query and return the contact for the requested name. Here you would decode
        // the incoming URI, query the data model based on the last name, and return the result
        // as a Cursor.

    ...

}






            Set up the getType() method to
            return an appropriate MIME type for copied data:
        

Kotlin

// Sets up your provider's getType() method.
override fun getType(uri: Uri): String? {
    ...

    return when(sUriMatcher.match(uri)) {
        GET_SINGLE_CONTACT -> MIME_TYPE_CONTACT
        ...
    }
}

Java

// Sets up your provider's getType() method.
public String getType(Uri uri) {
    ...

    switch (sUriMatcher.match(uri)) {
    case GET_SINGLE_CONTACT:
        return (MIME_TYPE_CONTACT);
    ...
    }
}






    The section Pasting data from a content URI
    describes how to get a content URI from the clipboard and use it to get and paste data.

Copying data streams

    You can copy and paste large amounts of text and binary data as streams. The data can have
    forms such as the following:



            Files stored on the actual device.
        

            Streams from sockets.
        

            Large amounts of data stored in a provider's underlying database system.
        


    A content provider for data streams provides access to its data with a file descriptor object
    such as AssetFileDescriptor instead of a
    Cursor object. The pasting application reads the data stream using
    this file descriptor.


    To set up your application to copy a data stream with a provider, follow these steps:



        Set up a content URI for the data stream you are putting on the clipboard. Options
        for doing this include the following:
        

                Encode an identifier for the data stream onto the URI,
                as described in the section
                Encoding an identifier on the URI, and then maintain a
                table in your provider that contains identifiers and the corresponding stream name.
            

                Encode the stream name directly on the URI.
            

                Use a unique URI that always returns the current stream from the provider. If you
                use this option, you have to remember to update your provider to point to a
                different stream whenever you copy the stream to the clipboard via the URI.
            



        Provide a MIME type for each type of data stream you plan to offer. Pasting applications
        need this information to determine if they can paste the data on the clipboard.
    

        Implement one of the ContentProvider methods that returns
        a file descriptor for a stream. If you encode identifiers on the content URI, use this
        method to determine which stream to open.
    

        To copy the data stream to the clipboard, construct the content URI and place it
        on the clipboard.
    


    To paste a data stream, an application gets the clip from the clipboard, gets the URI, and
    uses it in a call to a ContentResolver file descriptor method that
    opens the stream. The ContentResolver method calls the corresponding
    ContentProvider method, passing it the content URI. Your provider
    returns the file descriptor to ContentResolver method. The pasting
    application then has the responsibility to read the data from the stream.


    The following list shows the most important file descriptor methods for a content provider.
    Each of these has a corresponding ContentResolver method with the
    string "Descriptor" appended to the method name; for example, the
    ContentResolver analog of
    openAssetFile() is
openAssetFileDescriptor():



openTypedAssetFile()


        This method should return an asset file descriptor, but only if the provided MIME type is
        supported by the provider. The caller (the application doing the pasting) provides a MIME
        type pattern. The content provider (of the application that has copied a URI to the
        clipboard) returns an AssetFileDescriptor file handle if it
        can provide that MIME type, or throws an exception if it can not.
        
            This method handles subsections of files. You can use it to read assets that the
            content provider has copied to the clipboard.
        


openAssetFile()


        This method is a more general form of
openTypedAssetFile().
        It does not filter for allowed MIME types, but it can read subsections of files.
    

openFile()


        This is a more general form of
        openAssetFile(). It can't
        read subsections of files.
    


    You can optionally use the
openPipeHelper()
    method with your file descriptor method. This allows the pasting application to read the
    stream data in a background thread using a pipe. To use this method, you need to implement the
    ContentProvider.PipeDataWriter interface. An example of doing this is
    given in the Note Pad sample
    application, in the openTypedAssetFile() method of
    NotePadProvider.java.

Designing Effective Copy/Paste Functionality

    To design effective copy and paste functionality for your application, remember these
    points:



            At any time, there is only one clip on the clipboard. A new copy operation by
            any application in the system overwrites the previous clip. Since the user may
            navigate away from your application and do a copy before returning, you can't assume
            that the clipboard contains the clip that the user previously copied in your
            application.
        

            The intended purpose of multiple ClipData.Item
            objects per clip is to support copying and pasting of multiple selections rather than
            different forms of reference to a single selection. You usually want all of the
           ClipData.Item objects in a clip to have the same form, that is,
           they should all be simple text, content URI, or Intent, but not
           a mixture.
        

            When you provide data, you can offer different MIME representations. Add the MIME types
            you support to the ClipDescription, and then
            implement the MIME types in your content provider.
        

            When you get data from the clipboard, your application is responsible for checking the
            available MIME types and then deciding which one, if any, to use. Even if there is a
            clip on the clipboard and the user requests a paste, your application is not required
            to do the paste. You should do the paste if the MIME type is compatible. You
            may choose to coerce the data on the clipboard to text using
            coerceToText() if you
            choose. If your application supports more than one of the available MIME types, you can
            allow the user to choose which one to use.
        



Content and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates.

      
      Last updated February 13, 2019.
    





          
          
            Twitter
          
        Follow @AndroidDev on Twitter
          
          
            YouTube
          
        Check out Android Developers on YouTubeMore Android
                Android
            
                Enterprise
            
                Security
            
                Source
            Support
                Report platform bug
            
                Report documentation bug
            
                Google Play support
            
                Join user studies
            Documentation
                Developer guides
            
                Design guides
            
                API reference
            
                Samples
            
                Android Studio
            
                Android
            
                Chrome
            
                Firebase
            
                Google Cloud Platform
            
                All Products
            
            Bahasa Indonesia
          
            Deutsch
          
            English
          
            español
          
            Español (América Latina)
          
            français
          
            Português Brasileiro
          
            Tiếng Việt
          
            Türkçe
          
            Русский
          
            ภาษาไทย
          
            日本語
          
            简体中文
          
            繁體中文
          
            한국어
          Privacy
         License
         Brand Guidelines
         
        Get Android and Google Play news by email
      
        
        Subscribe
      
